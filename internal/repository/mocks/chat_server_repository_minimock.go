// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/erikqwerty/chat-server/internal/repository.ChatServerRepository -o chat_server_repository_minimock.go -n ChatServerRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"

	"github.com/erikqwerty/chat-server/internal/model"
)

// ChatServerRepositoryMock implements mm_repository.ChatServerRepository
type ChatServerRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateChat          func(ctx context.Context, s1 string) (i1 int, err error)
	funcCreateChatOrigin    string
	inspectFuncCreateChat   func(ctx context.Context, s1 string)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatServerRepositoryMockCreateChat

	funcCreateChatMember          func(ctx context.Context, cp1 *model.ChatMember) (err error)
	funcCreateChatMemberOrigin    string
	inspectFuncCreateChatMember   func(ctx context.Context, cp1 *model.ChatMember)
	afterCreateChatMemberCounter  uint64
	beforeCreateChatMemberCounter uint64
	CreateChatMemberMock          mChatServerRepositoryMockCreateChatMember

	funcCreateLog          func(ctx context.Context, log *model.Log) (err error)
	funcCreateLogOrigin    string
	inspectFuncCreateLog   func(ctx context.Context, log *model.Log)
	afterCreateLogCounter  uint64
	beforeCreateLogCounter uint64
	CreateLogMock          mChatServerRepositoryMockCreateLog

	funcCreateMessage          func(ctx context.Context, mp1 *model.Message) (i1 int, err error)
	funcCreateMessageOrigin    string
	inspectFuncCreateMessage   func(ctx context.Context, mp1 *model.Message)
	afterCreateMessageCounter  uint64
	beforeCreateMessageCounter uint64
	CreateMessageMock          mChatServerRepositoryMockCreateMessage

	funcDeleteChat          func(ctx context.Context, i1 int) (err error)
	funcDeleteChatOrigin    string
	inspectFuncDeleteChat   func(ctx context.Context, i1 int)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatServerRepositoryMockDeleteChat

	funcDeleteChatMember          func(ctx context.Context, cp1 *model.ChatMember) (err error)
	funcDeleteChatMemberOrigin    string
	inspectFuncDeleteChatMember   func(ctx context.Context, cp1 *model.ChatMember)
	afterDeleteChatMemberCounter  uint64
	beforeDeleteChatMemberCounter uint64
	DeleteChatMemberMock          mChatServerRepositoryMockDeleteChatMember

	funcDeleteMessage          func(ctx context.Context, i1 int) (err error)
	funcDeleteMessageOrigin    string
	inspectFuncDeleteMessage   func(ctx context.Context, i1 int)
	afterDeleteMessageCounter  uint64
	beforeDeleteMessageCounter uint64
	DeleteMessageMock          mChatServerRepositoryMockDeleteMessage

	funcReadChat          func(ctx context.Context, i1 int) (cp1 *model.Chat, err error)
	funcReadChatOrigin    string
	inspectFuncReadChat   func(ctx context.Context, i1 int)
	afterReadChatCounter  uint64
	beforeReadChatCounter uint64
	ReadChatMock          mChatServerRepositoryMockReadChat

	funcReadChatMember          func(ctx context.Context, cp1 *model.ChatMember) (cp2 *model.ChatMember, err error)
	funcReadChatMemberOrigin    string
	inspectFuncReadChatMember   func(ctx context.Context, cp1 *model.ChatMember)
	afterReadChatMemberCounter  uint64
	beforeReadChatMemberCounter uint64
	ReadChatMemberMock          mChatServerRepositoryMockReadChatMember

	funcReadChatMembers          func(ctx context.Context, i1 int) (cpa1 []*model.ChatMember, err error)
	funcReadChatMembersOrigin    string
	inspectFuncReadChatMembers   func(ctx context.Context, i1 int)
	afterReadChatMembersCounter  uint64
	beforeReadChatMembersCounter uint64
	ReadChatMembersMock          mChatServerRepositoryMockReadChatMembers

	funcReadChats          func(ctx context.Context) (cpa1 []*model.Chat, err error)
	funcReadChatsOrigin    string
	inspectFuncReadChats   func(ctx context.Context)
	afterReadChatsCounter  uint64
	beforeReadChatsCounter uint64
	ReadChatsMock          mChatServerRepositoryMockReadChats

	funcReadMessages          func(ctx context.Context, i1 int) (mpa1 []*model.Message, err error)
	funcReadMessagesOrigin    string
	inspectFuncReadMessages   func(ctx context.Context, i1 int)
	afterReadMessagesCounter  uint64
	beforeReadMessagesCounter uint64
	ReadMessagesMock          mChatServerRepositoryMockReadMessages
}

// NewChatServerRepositoryMock returns a mock for mm_repository.ChatServerRepository
func NewChatServerRepositoryMock(t minimock.Tester) *ChatServerRepositoryMock {
	m := &ChatServerRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateChatMock = mChatServerRepositoryMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatServerRepositoryMockCreateChatParams{}

	m.CreateChatMemberMock = mChatServerRepositoryMockCreateChatMember{mock: m}
	m.CreateChatMemberMock.callArgs = []*ChatServerRepositoryMockCreateChatMemberParams{}

	m.CreateLogMock = mChatServerRepositoryMockCreateLog{mock: m}
	m.CreateLogMock.callArgs = []*ChatServerRepositoryMockCreateLogParams{}

	m.CreateMessageMock = mChatServerRepositoryMockCreateMessage{mock: m}
	m.CreateMessageMock.callArgs = []*ChatServerRepositoryMockCreateMessageParams{}

	m.DeleteChatMock = mChatServerRepositoryMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatServerRepositoryMockDeleteChatParams{}

	m.DeleteChatMemberMock = mChatServerRepositoryMockDeleteChatMember{mock: m}
	m.DeleteChatMemberMock.callArgs = []*ChatServerRepositoryMockDeleteChatMemberParams{}

	m.DeleteMessageMock = mChatServerRepositoryMockDeleteMessage{mock: m}
	m.DeleteMessageMock.callArgs = []*ChatServerRepositoryMockDeleteMessageParams{}

	m.ReadChatMock = mChatServerRepositoryMockReadChat{mock: m}
	m.ReadChatMock.callArgs = []*ChatServerRepositoryMockReadChatParams{}

	m.ReadChatMemberMock = mChatServerRepositoryMockReadChatMember{mock: m}
	m.ReadChatMemberMock.callArgs = []*ChatServerRepositoryMockReadChatMemberParams{}

	m.ReadChatMembersMock = mChatServerRepositoryMockReadChatMembers{mock: m}
	m.ReadChatMembersMock.callArgs = []*ChatServerRepositoryMockReadChatMembersParams{}

	m.ReadChatsMock = mChatServerRepositoryMockReadChats{mock: m}
	m.ReadChatsMock.callArgs = []*ChatServerRepositoryMockReadChatsParams{}

	m.ReadMessagesMock = mChatServerRepositoryMockReadMessages{mock: m}
	m.ReadMessagesMock.callArgs = []*ChatServerRepositoryMockReadMessagesParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServerRepositoryMockCreateChat struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockCreateChatExpectation
	expectations       []*ChatServerRepositoryMockCreateChatExpectation

	callArgs []*ChatServerRepositoryMockCreateChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockCreateChatExpectation specifies expectation struct of the ChatServerRepository.CreateChat
type ChatServerRepositoryMockCreateChatExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockCreateChatParams
	paramPtrs          *ChatServerRepositoryMockCreateChatParamPtrs
	expectationOrigins ChatServerRepositoryMockCreateChatExpectationOrigins
	results            *ChatServerRepositoryMockCreateChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockCreateChatParams contains parameters of the ChatServerRepository.CreateChat
type ChatServerRepositoryMockCreateChatParams struct {
	ctx context.Context
	s1  string
}

// ChatServerRepositoryMockCreateChatParamPtrs contains pointers to parameters of the ChatServerRepository.CreateChat
type ChatServerRepositoryMockCreateChatParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ChatServerRepositoryMockCreateChatResults contains results of the ChatServerRepository.CreateChat
type ChatServerRepositoryMockCreateChatResults struct {
	i1  int
	err error
}

// ChatServerRepositoryMockCreateChatOrigins contains origins of expectations of the ChatServerRepository.CreateChat
type ChatServerRepositoryMockCreateChatExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mChatServerRepositoryMockCreateChat) Optional() *mChatServerRepositoryMockCreateChat {
	mmCreateChat.optional = true
	return mmCreateChat
}

// Expect sets up expected params for ChatServerRepository.CreateChat
func (mmCreateChat *mChatServerRepositoryMockCreateChat) Expect(ctx context.Context, s1 string) *mChatServerRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServerRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.paramPtrs != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerRepositoryMock.CreateChat mock is already set by ExpectParams functions")
	}

	mmCreateChat.defaultExpectation.params = &ChatServerRepositoryMockCreateChatParams{ctx, s1}
	mmCreateChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.CreateChat
func (mmCreateChat *mChatServerRepositoryMockCreateChat) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServerRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerRepositoryMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatServerRepositoryMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateChat
}

// ExpectS1Param2 sets up expected param s1 for ChatServerRepository.CreateChat
func (mmCreateChat *mChatServerRepositoryMockCreateChat) ExpectS1Param2(s1 string) *mChatServerRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServerRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerRepositoryMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatServerRepositoryMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.s1 = &s1
	mmCreateChat.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.CreateChat
func (mmCreateChat *mChatServerRepositoryMockCreateChat) Inspect(f func(ctx context.Context, s1 string)) *mChatServerRepositoryMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatServerRepository.CreateChat
func (mmCreateChat *mChatServerRepositoryMockCreateChat) Return(i1 int, err error) *ChatServerRepositoryMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServerRepositoryMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatServerRepositoryMockCreateChatResults{i1, err}
	mmCreateChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatServerRepository.CreateChat method
func (mmCreateChat *mChatServerRepositoryMockCreateChat) Set(f func(ctx context.Context, s1 string) (i1 int, err error)) *ChatServerRepositoryMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	mmCreateChat.mock.funcCreateChatOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// When sets expectation for the ChatServerRepository.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatServerRepositoryMockCreateChat) When(ctx context.Context, s1 string) *ChatServerRepositoryMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServerRepositoryMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockCreateChatExpectation{
		mock:               mmCreateChat.mock,
		params:             &ChatServerRepositoryMockCreateChatParams{ctx, s1},
		expectationOrigins: ChatServerRepositoryMockCreateChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockCreateChatExpectation) Then(i1 int, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockCreateChatResults{i1, err}
	return e.mock
}

// Times sets number of times ChatServerRepository.CreateChat should be invoked
func (mmCreateChat *mChatServerRepositoryMockCreateChat) Times(n uint64) *mChatServerRepositoryMockCreateChat {
	if n == 0 {
		mmCreateChat.mock.t.Fatalf("Times of ChatServerRepositoryMock.CreateChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChat.expectedInvocations, n)
	mmCreateChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateChat
}

func (mmCreateChat *mChatServerRepositoryMockCreateChat) invocationsDone() bool {
	if len(mmCreateChat.expectations) == 0 && mmCreateChat.defaultExpectation == nil && mmCreateChat.mock.funcCreateChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChat.mock.afterCreateChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChat implements mm_repository.ChatServerRepository
func (mmCreateChat *ChatServerRepositoryMock) CreateChat(ctx context.Context, s1 string) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	mmCreateChat.t.Helper()

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, s1)
	}

	mm_params := ChatServerRepositoryMockCreateChatParams{ctx, s1}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockCreateChatParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChat.t.Errorf("ChatServerRepositoryMock.CreateChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmCreateChat.t.Errorf("ChatServerRepositoryMock.CreateChat got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatServerRepositoryMock.CreateChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatServerRepositoryMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, s1)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatServerRepositoryMock.CreateChat. %v %v", ctx, s1)
	return
}

// CreateChatAfterCounter returns a count of finished ChatServerRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatServerRepositoryMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatServerRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatServerRepositoryMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatServerRepositoryMockCreateChat) Calls() []*ChatServerRepositoryMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockCreateChatDone() bool {
	if m.CreateChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMock.invocationsDone()
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateChatCounter := mm_atomic.LoadUint64(&m.afterCreateChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && afterCreateChatCounter < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateChat at\n%s", m.CreateChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateChat at\n%s with params: %#v", m.CreateChatMock.defaultExpectation.expectationOrigins.origin, *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && afterCreateChatCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateChat at\n%s", m.funcCreateChatOrigin)
	}

	if !m.CreateChatMock.invocationsDone() && afterCreateChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.CreateChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMock.expectedInvocations), m.CreateChatMock.expectedInvocationsOrigin, afterCreateChatCounter)
	}
}

type mChatServerRepositoryMockCreateChatMember struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockCreateChatMemberExpectation
	expectations       []*ChatServerRepositoryMockCreateChatMemberExpectation

	callArgs []*ChatServerRepositoryMockCreateChatMemberParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockCreateChatMemberExpectation specifies expectation struct of the ChatServerRepository.CreateChatMember
type ChatServerRepositoryMockCreateChatMemberExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockCreateChatMemberParams
	paramPtrs          *ChatServerRepositoryMockCreateChatMemberParamPtrs
	expectationOrigins ChatServerRepositoryMockCreateChatMemberExpectationOrigins
	results            *ChatServerRepositoryMockCreateChatMemberResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockCreateChatMemberParams contains parameters of the ChatServerRepository.CreateChatMember
type ChatServerRepositoryMockCreateChatMemberParams struct {
	ctx context.Context
	cp1 *model.ChatMember
}

// ChatServerRepositoryMockCreateChatMemberParamPtrs contains pointers to parameters of the ChatServerRepository.CreateChatMember
type ChatServerRepositoryMockCreateChatMemberParamPtrs struct {
	ctx *context.Context
	cp1 **model.ChatMember
}

// ChatServerRepositoryMockCreateChatMemberResults contains results of the ChatServerRepository.CreateChatMember
type ChatServerRepositoryMockCreateChatMemberResults struct {
	err error
}

// ChatServerRepositoryMockCreateChatMemberOrigins contains origins of expectations of the ChatServerRepository.CreateChatMember
type ChatServerRepositoryMockCreateChatMemberExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChatMember *mChatServerRepositoryMockCreateChatMember) Optional() *mChatServerRepositoryMockCreateChatMember {
	mmCreateChatMember.optional = true
	return mmCreateChatMember
}

// Expect sets up expected params for ChatServerRepository.CreateChatMember
func (mmCreateChatMember *mChatServerRepositoryMockCreateChatMember) Expect(ctx context.Context, cp1 *model.ChatMember) *mChatServerRepositoryMockCreateChatMember {
	if mmCreateChatMember.mock.funcCreateChatMember != nil {
		mmCreateChatMember.mock.t.Fatalf("ChatServerRepositoryMock.CreateChatMember mock is already set by Set")
	}

	if mmCreateChatMember.defaultExpectation == nil {
		mmCreateChatMember.defaultExpectation = &ChatServerRepositoryMockCreateChatMemberExpectation{}
	}

	if mmCreateChatMember.defaultExpectation.paramPtrs != nil {
		mmCreateChatMember.mock.t.Fatalf("ChatServerRepositoryMock.CreateChatMember mock is already set by ExpectParams functions")
	}

	mmCreateChatMember.defaultExpectation.params = &ChatServerRepositoryMockCreateChatMemberParams{ctx, cp1}
	mmCreateChatMember.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateChatMember.expectations {
		if minimock.Equal(e.params, mmCreateChatMember.defaultExpectation.params) {
			mmCreateChatMember.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChatMember.defaultExpectation.params)
		}
	}

	return mmCreateChatMember
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.CreateChatMember
func (mmCreateChatMember *mChatServerRepositoryMockCreateChatMember) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockCreateChatMember {
	if mmCreateChatMember.mock.funcCreateChatMember != nil {
		mmCreateChatMember.mock.t.Fatalf("ChatServerRepositoryMock.CreateChatMember mock is already set by Set")
	}

	if mmCreateChatMember.defaultExpectation == nil {
		mmCreateChatMember.defaultExpectation = &ChatServerRepositoryMockCreateChatMemberExpectation{}
	}

	if mmCreateChatMember.defaultExpectation.params != nil {
		mmCreateChatMember.mock.t.Fatalf("ChatServerRepositoryMock.CreateChatMember mock is already set by Expect")
	}

	if mmCreateChatMember.defaultExpectation.paramPtrs == nil {
		mmCreateChatMember.defaultExpectation.paramPtrs = &ChatServerRepositoryMockCreateChatMemberParamPtrs{}
	}
	mmCreateChatMember.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateChatMember.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateChatMember
}

// ExpectCp1Param2 sets up expected param cp1 for ChatServerRepository.CreateChatMember
func (mmCreateChatMember *mChatServerRepositoryMockCreateChatMember) ExpectCp1Param2(cp1 *model.ChatMember) *mChatServerRepositoryMockCreateChatMember {
	if mmCreateChatMember.mock.funcCreateChatMember != nil {
		mmCreateChatMember.mock.t.Fatalf("ChatServerRepositoryMock.CreateChatMember mock is already set by Set")
	}

	if mmCreateChatMember.defaultExpectation == nil {
		mmCreateChatMember.defaultExpectation = &ChatServerRepositoryMockCreateChatMemberExpectation{}
	}

	if mmCreateChatMember.defaultExpectation.params != nil {
		mmCreateChatMember.mock.t.Fatalf("ChatServerRepositoryMock.CreateChatMember mock is already set by Expect")
	}

	if mmCreateChatMember.defaultExpectation.paramPtrs == nil {
		mmCreateChatMember.defaultExpectation.paramPtrs = &ChatServerRepositoryMockCreateChatMemberParamPtrs{}
	}
	mmCreateChatMember.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateChatMember.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateChatMember
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.CreateChatMember
func (mmCreateChatMember *mChatServerRepositoryMockCreateChatMember) Inspect(f func(ctx context.Context, cp1 *model.ChatMember)) *mChatServerRepositoryMockCreateChatMember {
	if mmCreateChatMember.mock.inspectFuncCreateChatMember != nil {
		mmCreateChatMember.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.CreateChatMember")
	}

	mmCreateChatMember.mock.inspectFuncCreateChatMember = f

	return mmCreateChatMember
}

// Return sets up results that will be returned by ChatServerRepository.CreateChatMember
func (mmCreateChatMember *mChatServerRepositoryMockCreateChatMember) Return(err error) *ChatServerRepositoryMock {
	if mmCreateChatMember.mock.funcCreateChatMember != nil {
		mmCreateChatMember.mock.t.Fatalf("ChatServerRepositoryMock.CreateChatMember mock is already set by Set")
	}

	if mmCreateChatMember.defaultExpectation == nil {
		mmCreateChatMember.defaultExpectation = &ChatServerRepositoryMockCreateChatMemberExpectation{mock: mmCreateChatMember.mock}
	}
	mmCreateChatMember.defaultExpectation.results = &ChatServerRepositoryMockCreateChatMemberResults{err}
	mmCreateChatMember.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateChatMember.mock
}

// Set uses given function f to mock the ChatServerRepository.CreateChatMember method
func (mmCreateChatMember *mChatServerRepositoryMockCreateChatMember) Set(f func(ctx context.Context, cp1 *model.ChatMember) (err error)) *ChatServerRepositoryMock {
	if mmCreateChatMember.defaultExpectation != nil {
		mmCreateChatMember.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.CreateChatMember method")
	}

	if len(mmCreateChatMember.expectations) > 0 {
		mmCreateChatMember.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.CreateChatMember method")
	}

	mmCreateChatMember.mock.funcCreateChatMember = f
	mmCreateChatMember.mock.funcCreateChatMemberOrigin = minimock.CallerInfo(1)
	return mmCreateChatMember.mock
}

// When sets expectation for the ChatServerRepository.CreateChatMember which will trigger the result defined by the following
// Then helper
func (mmCreateChatMember *mChatServerRepositoryMockCreateChatMember) When(ctx context.Context, cp1 *model.ChatMember) *ChatServerRepositoryMockCreateChatMemberExpectation {
	if mmCreateChatMember.mock.funcCreateChatMember != nil {
		mmCreateChatMember.mock.t.Fatalf("ChatServerRepositoryMock.CreateChatMember mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockCreateChatMemberExpectation{
		mock:               mmCreateChatMember.mock,
		params:             &ChatServerRepositoryMockCreateChatMemberParams{ctx, cp1},
		expectationOrigins: ChatServerRepositoryMockCreateChatMemberExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateChatMember.expectations = append(mmCreateChatMember.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.CreateChatMember return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockCreateChatMemberExpectation) Then(err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockCreateChatMemberResults{err}
	return e.mock
}

// Times sets number of times ChatServerRepository.CreateChatMember should be invoked
func (mmCreateChatMember *mChatServerRepositoryMockCreateChatMember) Times(n uint64) *mChatServerRepositoryMockCreateChatMember {
	if n == 0 {
		mmCreateChatMember.mock.t.Fatalf("Times of ChatServerRepositoryMock.CreateChatMember mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChatMember.expectedInvocations, n)
	mmCreateChatMember.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateChatMember
}

func (mmCreateChatMember *mChatServerRepositoryMockCreateChatMember) invocationsDone() bool {
	if len(mmCreateChatMember.expectations) == 0 && mmCreateChatMember.defaultExpectation == nil && mmCreateChatMember.mock.funcCreateChatMember == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChatMember.mock.afterCreateChatMemberCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChatMember.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChatMember implements mm_repository.ChatServerRepository
func (mmCreateChatMember *ChatServerRepositoryMock) CreateChatMember(ctx context.Context, cp1 *model.ChatMember) (err error) {
	mm_atomic.AddUint64(&mmCreateChatMember.beforeCreateChatMemberCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChatMember.afterCreateChatMemberCounter, 1)

	mmCreateChatMember.t.Helper()

	if mmCreateChatMember.inspectFuncCreateChatMember != nil {
		mmCreateChatMember.inspectFuncCreateChatMember(ctx, cp1)
	}

	mm_params := ChatServerRepositoryMockCreateChatMemberParams{ctx, cp1}

	// Record call args
	mmCreateChatMember.CreateChatMemberMock.mutex.Lock()
	mmCreateChatMember.CreateChatMemberMock.callArgs = append(mmCreateChatMember.CreateChatMemberMock.callArgs, &mm_params)
	mmCreateChatMember.CreateChatMemberMock.mutex.Unlock()

	for _, e := range mmCreateChatMember.CreateChatMemberMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateChatMember.CreateChatMemberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChatMember.CreateChatMemberMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChatMember.CreateChatMemberMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChatMember.CreateChatMemberMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockCreateChatMemberParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChatMember.t.Errorf("ChatServerRepositoryMock.CreateChatMember got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChatMember.CreateChatMemberMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateChatMember.t.Errorf("ChatServerRepositoryMock.CreateChatMember got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChatMember.CreateChatMemberMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChatMember.t.Errorf("ChatServerRepositoryMock.CreateChatMember got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateChatMember.CreateChatMemberMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChatMember.CreateChatMemberMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChatMember.t.Fatal("No results are set for the ChatServerRepositoryMock.CreateChatMember")
		}
		return (*mm_results).err
	}
	if mmCreateChatMember.funcCreateChatMember != nil {
		return mmCreateChatMember.funcCreateChatMember(ctx, cp1)
	}
	mmCreateChatMember.t.Fatalf("Unexpected call to ChatServerRepositoryMock.CreateChatMember. %v %v", ctx, cp1)
	return
}

// CreateChatMemberAfterCounter returns a count of finished ChatServerRepositoryMock.CreateChatMember invocations
func (mmCreateChatMember *ChatServerRepositoryMock) CreateChatMemberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChatMember.afterCreateChatMemberCounter)
}

// CreateChatMemberBeforeCounter returns a count of ChatServerRepositoryMock.CreateChatMember invocations
func (mmCreateChatMember *ChatServerRepositoryMock) CreateChatMemberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChatMember.beforeCreateChatMemberCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.CreateChatMember.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChatMember *mChatServerRepositoryMockCreateChatMember) Calls() []*ChatServerRepositoryMockCreateChatMemberParams {
	mmCreateChatMember.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockCreateChatMemberParams, len(mmCreateChatMember.callArgs))
	copy(argCopy, mmCreateChatMember.callArgs)

	mmCreateChatMember.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatMemberDone returns true if the count of the CreateChatMember invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockCreateChatMemberDone() bool {
	if m.CreateChatMemberMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMemberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMemberMock.invocationsDone()
}

// MinimockCreateChatMemberInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockCreateChatMemberInspect() {
	for _, e := range m.CreateChatMemberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateChatMember at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateChatMemberCounter := mm_atomic.LoadUint64(&m.afterCreateChatMemberCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMemberMock.defaultExpectation != nil && afterCreateChatMemberCounter < 1 {
		if m.CreateChatMemberMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateChatMember at\n%s", m.CreateChatMemberMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateChatMember at\n%s with params: %#v", m.CreateChatMemberMock.defaultExpectation.expectationOrigins.origin, *m.CreateChatMemberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChatMember != nil && afterCreateChatMemberCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateChatMember at\n%s", m.funcCreateChatMemberOrigin)
	}

	if !m.CreateChatMemberMock.invocationsDone() && afterCreateChatMemberCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.CreateChatMember at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMemberMock.expectedInvocations), m.CreateChatMemberMock.expectedInvocationsOrigin, afterCreateChatMemberCounter)
	}
}

type mChatServerRepositoryMockCreateLog struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockCreateLogExpectation
	expectations       []*ChatServerRepositoryMockCreateLogExpectation

	callArgs []*ChatServerRepositoryMockCreateLogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockCreateLogExpectation specifies expectation struct of the ChatServerRepository.CreateLog
type ChatServerRepositoryMockCreateLogExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockCreateLogParams
	paramPtrs          *ChatServerRepositoryMockCreateLogParamPtrs
	expectationOrigins ChatServerRepositoryMockCreateLogExpectationOrigins
	results            *ChatServerRepositoryMockCreateLogResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockCreateLogParams contains parameters of the ChatServerRepository.CreateLog
type ChatServerRepositoryMockCreateLogParams struct {
	ctx context.Context
	log *model.Log
}

// ChatServerRepositoryMockCreateLogParamPtrs contains pointers to parameters of the ChatServerRepository.CreateLog
type ChatServerRepositoryMockCreateLogParamPtrs struct {
	ctx *context.Context
	log **model.Log
}

// ChatServerRepositoryMockCreateLogResults contains results of the ChatServerRepository.CreateLog
type ChatServerRepositoryMockCreateLogResults struct {
	err error
}

// ChatServerRepositoryMockCreateLogOrigins contains origins of expectations of the ChatServerRepository.CreateLog
type ChatServerRepositoryMockCreateLogExpectationOrigins struct {
	origin    string
	originCtx string
	originLog string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateLog *mChatServerRepositoryMockCreateLog) Optional() *mChatServerRepositoryMockCreateLog {
	mmCreateLog.optional = true
	return mmCreateLog
}

// Expect sets up expected params for ChatServerRepository.CreateLog
func (mmCreateLog *mChatServerRepositoryMockCreateLog) Expect(ctx context.Context, log *model.Log) *mChatServerRepositoryMockCreateLog {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("ChatServerRepositoryMock.CreateLog mock is already set by Set")
	}

	if mmCreateLog.defaultExpectation == nil {
		mmCreateLog.defaultExpectation = &ChatServerRepositoryMockCreateLogExpectation{}
	}

	if mmCreateLog.defaultExpectation.paramPtrs != nil {
		mmCreateLog.mock.t.Fatalf("ChatServerRepositoryMock.CreateLog mock is already set by ExpectParams functions")
	}

	mmCreateLog.defaultExpectation.params = &ChatServerRepositoryMockCreateLogParams{ctx, log}
	mmCreateLog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateLog.expectations {
		if minimock.Equal(e.params, mmCreateLog.defaultExpectation.params) {
			mmCreateLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateLog.defaultExpectation.params)
		}
	}

	return mmCreateLog
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.CreateLog
func (mmCreateLog *mChatServerRepositoryMockCreateLog) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockCreateLog {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("ChatServerRepositoryMock.CreateLog mock is already set by Set")
	}

	if mmCreateLog.defaultExpectation == nil {
		mmCreateLog.defaultExpectation = &ChatServerRepositoryMockCreateLogExpectation{}
	}

	if mmCreateLog.defaultExpectation.params != nil {
		mmCreateLog.mock.t.Fatalf("ChatServerRepositoryMock.CreateLog mock is already set by Expect")
	}

	if mmCreateLog.defaultExpectation.paramPtrs == nil {
		mmCreateLog.defaultExpectation.paramPtrs = &ChatServerRepositoryMockCreateLogParamPtrs{}
	}
	mmCreateLog.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateLog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateLog
}

// ExpectLogParam2 sets up expected param log for ChatServerRepository.CreateLog
func (mmCreateLog *mChatServerRepositoryMockCreateLog) ExpectLogParam2(log *model.Log) *mChatServerRepositoryMockCreateLog {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("ChatServerRepositoryMock.CreateLog mock is already set by Set")
	}

	if mmCreateLog.defaultExpectation == nil {
		mmCreateLog.defaultExpectation = &ChatServerRepositoryMockCreateLogExpectation{}
	}

	if mmCreateLog.defaultExpectation.params != nil {
		mmCreateLog.mock.t.Fatalf("ChatServerRepositoryMock.CreateLog mock is already set by Expect")
	}

	if mmCreateLog.defaultExpectation.paramPtrs == nil {
		mmCreateLog.defaultExpectation.paramPtrs = &ChatServerRepositoryMockCreateLogParamPtrs{}
	}
	mmCreateLog.defaultExpectation.paramPtrs.log = &log
	mmCreateLog.defaultExpectation.expectationOrigins.originLog = minimock.CallerInfo(1)

	return mmCreateLog
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.CreateLog
func (mmCreateLog *mChatServerRepositoryMockCreateLog) Inspect(f func(ctx context.Context, log *model.Log)) *mChatServerRepositoryMockCreateLog {
	if mmCreateLog.mock.inspectFuncCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.CreateLog")
	}

	mmCreateLog.mock.inspectFuncCreateLog = f

	return mmCreateLog
}

// Return sets up results that will be returned by ChatServerRepository.CreateLog
func (mmCreateLog *mChatServerRepositoryMockCreateLog) Return(err error) *ChatServerRepositoryMock {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("ChatServerRepositoryMock.CreateLog mock is already set by Set")
	}

	if mmCreateLog.defaultExpectation == nil {
		mmCreateLog.defaultExpectation = &ChatServerRepositoryMockCreateLogExpectation{mock: mmCreateLog.mock}
	}
	mmCreateLog.defaultExpectation.results = &ChatServerRepositoryMockCreateLogResults{err}
	mmCreateLog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateLog.mock
}

// Set uses given function f to mock the ChatServerRepository.CreateLog method
func (mmCreateLog *mChatServerRepositoryMockCreateLog) Set(f func(ctx context.Context, log *model.Log) (err error)) *ChatServerRepositoryMock {
	if mmCreateLog.defaultExpectation != nil {
		mmCreateLog.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.CreateLog method")
	}

	if len(mmCreateLog.expectations) > 0 {
		mmCreateLog.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.CreateLog method")
	}

	mmCreateLog.mock.funcCreateLog = f
	mmCreateLog.mock.funcCreateLogOrigin = minimock.CallerInfo(1)
	return mmCreateLog.mock
}

// When sets expectation for the ChatServerRepository.CreateLog which will trigger the result defined by the following
// Then helper
func (mmCreateLog *mChatServerRepositoryMockCreateLog) When(ctx context.Context, log *model.Log) *ChatServerRepositoryMockCreateLogExpectation {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("ChatServerRepositoryMock.CreateLog mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockCreateLogExpectation{
		mock:               mmCreateLog.mock,
		params:             &ChatServerRepositoryMockCreateLogParams{ctx, log},
		expectationOrigins: ChatServerRepositoryMockCreateLogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateLog.expectations = append(mmCreateLog.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.CreateLog return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockCreateLogExpectation) Then(err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockCreateLogResults{err}
	return e.mock
}

// Times sets number of times ChatServerRepository.CreateLog should be invoked
func (mmCreateLog *mChatServerRepositoryMockCreateLog) Times(n uint64) *mChatServerRepositoryMockCreateLog {
	if n == 0 {
		mmCreateLog.mock.t.Fatalf("Times of ChatServerRepositoryMock.CreateLog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateLog.expectedInvocations, n)
	mmCreateLog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateLog
}

func (mmCreateLog *mChatServerRepositoryMockCreateLog) invocationsDone() bool {
	if len(mmCreateLog.expectations) == 0 && mmCreateLog.defaultExpectation == nil && mmCreateLog.mock.funcCreateLog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateLog.mock.afterCreateLogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateLog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateLog implements mm_repository.ChatServerRepository
func (mmCreateLog *ChatServerRepositoryMock) CreateLog(ctx context.Context, log *model.Log) (err error) {
	mm_atomic.AddUint64(&mmCreateLog.beforeCreateLogCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateLog.afterCreateLogCounter, 1)

	mmCreateLog.t.Helper()

	if mmCreateLog.inspectFuncCreateLog != nil {
		mmCreateLog.inspectFuncCreateLog(ctx, log)
	}

	mm_params := ChatServerRepositoryMockCreateLogParams{ctx, log}

	// Record call args
	mmCreateLog.CreateLogMock.mutex.Lock()
	mmCreateLog.CreateLogMock.callArgs = append(mmCreateLog.CreateLogMock.callArgs, &mm_params)
	mmCreateLog.CreateLogMock.mutex.Unlock()

	for _, e := range mmCreateLog.CreateLogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateLog.CreateLogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateLog.CreateLogMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateLog.CreateLogMock.defaultExpectation.params
		mm_want_ptrs := mmCreateLog.CreateLogMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockCreateLogParams{ctx, log}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateLog.t.Errorf("ChatServerRepositoryMock.CreateLog got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateLog.CreateLogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.log != nil && !minimock.Equal(*mm_want_ptrs.log, mm_got.log) {
				mmCreateLog.t.Errorf("ChatServerRepositoryMock.CreateLog got unexpected parameter log, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateLog.CreateLogMock.defaultExpectation.expectationOrigins.originLog, *mm_want_ptrs.log, mm_got.log, minimock.Diff(*mm_want_ptrs.log, mm_got.log))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateLog.t.Errorf("ChatServerRepositoryMock.CreateLog got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateLog.CreateLogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateLog.CreateLogMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateLog.t.Fatal("No results are set for the ChatServerRepositoryMock.CreateLog")
		}
		return (*mm_results).err
	}
	if mmCreateLog.funcCreateLog != nil {
		return mmCreateLog.funcCreateLog(ctx, log)
	}
	mmCreateLog.t.Fatalf("Unexpected call to ChatServerRepositoryMock.CreateLog. %v %v", ctx, log)
	return
}

// CreateLogAfterCounter returns a count of finished ChatServerRepositoryMock.CreateLog invocations
func (mmCreateLog *ChatServerRepositoryMock) CreateLogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateLog.afterCreateLogCounter)
}

// CreateLogBeforeCounter returns a count of ChatServerRepositoryMock.CreateLog invocations
func (mmCreateLog *ChatServerRepositoryMock) CreateLogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateLog.beforeCreateLogCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.CreateLog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateLog *mChatServerRepositoryMockCreateLog) Calls() []*ChatServerRepositoryMockCreateLogParams {
	mmCreateLog.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockCreateLogParams, len(mmCreateLog.callArgs))
	copy(argCopy, mmCreateLog.callArgs)

	mmCreateLog.mutex.RUnlock()

	return argCopy
}

// MinimockCreateLogDone returns true if the count of the CreateLog invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockCreateLogDone() bool {
	if m.CreateLogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateLogMock.invocationsDone()
}

// MinimockCreateLogInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockCreateLogInspect() {
	for _, e := range m.CreateLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateLog at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateLogCounter := mm_atomic.LoadUint64(&m.afterCreateLogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateLogMock.defaultExpectation != nil && afterCreateLogCounter < 1 {
		if m.CreateLogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateLog at\n%s", m.CreateLogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateLog at\n%s with params: %#v", m.CreateLogMock.defaultExpectation.expectationOrigins.origin, *m.CreateLogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateLog != nil && afterCreateLogCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateLog at\n%s", m.funcCreateLogOrigin)
	}

	if !m.CreateLogMock.invocationsDone() && afterCreateLogCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.CreateLog at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateLogMock.expectedInvocations), m.CreateLogMock.expectedInvocationsOrigin, afterCreateLogCounter)
	}
}

type mChatServerRepositoryMockCreateMessage struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockCreateMessageExpectation
	expectations       []*ChatServerRepositoryMockCreateMessageExpectation

	callArgs []*ChatServerRepositoryMockCreateMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockCreateMessageExpectation specifies expectation struct of the ChatServerRepository.CreateMessage
type ChatServerRepositoryMockCreateMessageExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockCreateMessageParams
	paramPtrs          *ChatServerRepositoryMockCreateMessageParamPtrs
	expectationOrigins ChatServerRepositoryMockCreateMessageExpectationOrigins
	results            *ChatServerRepositoryMockCreateMessageResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockCreateMessageParams contains parameters of the ChatServerRepository.CreateMessage
type ChatServerRepositoryMockCreateMessageParams struct {
	ctx context.Context
	mp1 *model.Message
}

// ChatServerRepositoryMockCreateMessageParamPtrs contains pointers to parameters of the ChatServerRepository.CreateMessage
type ChatServerRepositoryMockCreateMessageParamPtrs struct {
	ctx *context.Context
	mp1 **model.Message
}

// ChatServerRepositoryMockCreateMessageResults contains results of the ChatServerRepository.CreateMessage
type ChatServerRepositoryMockCreateMessageResults struct {
	i1  int
	err error
}

// ChatServerRepositoryMockCreateMessageOrigins contains origins of expectations of the ChatServerRepository.CreateMessage
type ChatServerRepositoryMockCreateMessageExpectationOrigins struct {
	origin    string
	originCtx string
	originMp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateMessage *mChatServerRepositoryMockCreateMessage) Optional() *mChatServerRepositoryMockCreateMessage {
	mmCreateMessage.optional = true
	return mmCreateMessage
}

// Expect sets up expected params for ChatServerRepository.CreateMessage
func (mmCreateMessage *mChatServerRepositoryMockCreateMessage) Expect(ctx context.Context, mp1 *model.Message) *mChatServerRepositoryMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServerRepositoryMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatServerRepositoryMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.paramPtrs != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServerRepositoryMock.CreateMessage mock is already set by ExpectParams functions")
	}

	mmCreateMessage.defaultExpectation.params = &ChatServerRepositoryMockCreateMessageParams{ctx, mp1}
	mmCreateMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateMessage.expectations {
		if minimock.Equal(e.params, mmCreateMessage.defaultExpectation.params) {
			mmCreateMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateMessage.defaultExpectation.params)
		}
	}

	return mmCreateMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.CreateMessage
func (mmCreateMessage *mChatServerRepositoryMockCreateMessage) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServerRepositoryMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatServerRepositoryMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServerRepositoryMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &ChatServerRepositoryMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateMessage
}

// ExpectMp1Param2 sets up expected param mp1 for ChatServerRepository.CreateMessage
func (mmCreateMessage *mChatServerRepositoryMockCreateMessage) ExpectMp1Param2(mp1 *model.Message) *mChatServerRepositoryMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServerRepositoryMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatServerRepositoryMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServerRepositoryMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &ChatServerRepositoryMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.mp1 = &mp1
	mmCreateMessage.defaultExpectation.expectationOrigins.originMp1 = minimock.CallerInfo(1)

	return mmCreateMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.CreateMessage
func (mmCreateMessage *mChatServerRepositoryMockCreateMessage) Inspect(f func(ctx context.Context, mp1 *model.Message)) *mChatServerRepositoryMockCreateMessage {
	if mmCreateMessage.mock.inspectFuncCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.CreateMessage")
	}

	mmCreateMessage.mock.inspectFuncCreateMessage = f

	return mmCreateMessage
}

// Return sets up results that will be returned by ChatServerRepository.CreateMessage
func (mmCreateMessage *mChatServerRepositoryMockCreateMessage) Return(i1 int, err error) *ChatServerRepositoryMock {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServerRepositoryMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &ChatServerRepositoryMockCreateMessageExpectation{mock: mmCreateMessage.mock}
	}
	mmCreateMessage.defaultExpectation.results = &ChatServerRepositoryMockCreateMessageResults{i1, err}
	mmCreateMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateMessage.mock
}

// Set uses given function f to mock the ChatServerRepository.CreateMessage method
func (mmCreateMessage *mChatServerRepositoryMockCreateMessage) Set(f func(ctx context.Context, mp1 *model.Message) (i1 int, err error)) *ChatServerRepositoryMock {
	if mmCreateMessage.defaultExpectation != nil {
		mmCreateMessage.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.CreateMessage method")
	}

	if len(mmCreateMessage.expectations) > 0 {
		mmCreateMessage.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.CreateMessage method")
	}

	mmCreateMessage.mock.funcCreateMessage = f
	mmCreateMessage.mock.funcCreateMessageOrigin = minimock.CallerInfo(1)
	return mmCreateMessage.mock
}

// When sets expectation for the ChatServerRepository.CreateMessage which will trigger the result defined by the following
// Then helper
func (mmCreateMessage *mChatServerRepositoryMockCreateMessage) When(ctx context.Context, mp1 *model.Message) *ChatServerRepositoryMockCreateMessageExpectation {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("ChatServerRepositoryMock.CreateMessage mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockCreateMessageExpectation{
		mock:               mmCreateMessage.mock,
		params:             &ChatServerRepositoryMockCreateMessageParams{ctx, mp1},
		expectationOrigins: ChatServerRepositoryMockCreateMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateMessage.expectations = append(mmCreateMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.CreateMessage return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockCreateMessageExpectation) Then(i1 int, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockCreateMessageResults{i1, err}
	return e.mock
}

// Times sets number of times ChatServerRepository.CreateMessage should be invoked
func (mmCreateMessage *mChatServerRepositoryMockCreateMessage) Times(n uint64) *mChatServerRepositoryMockCreateMessage {
	if n == 0 {
		mmCreateMessage.mock.t.Fatalf("Times of ChatServerRepositoryMock.CreateMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateMessage.expectedInvocations, n)
	mmCreateMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateMessage
}

func (mmCreateMessage *mChatServerRepositoryMockCreateMessage) invocationsDone() bool {
	if len(mmCreateMessage.expectations) == 0 && mmCreateMessage.defaultExpectation == nil && mmCreateMessage.mock.funcCreateMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateMessage.mock.afterCreateMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateMessage implements mm_repository.ChatServerRepository
func (mmCreateMessage *ChatServerRepositoryMock) CreateMessage(ctx context.Context, mp1 *model.Message) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateMessage.beforeCreateMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateMessage.afterCreateMessageCounter, 1)

	mmCreateMessage.t.Helper()

	if mmCreateMessage.inspectFuncCreateMessage != nil {
		mmCreateMessage.inspectFuncCreateMessage(ctx, mp1)
	}

	mm_params := ChatServerRepositoryMockCreateMessageParams{ctx, mp1}

	// Record call args
	mmCreateMessage.CreateMessageMock.mutex.Lock()
	mmCreateMessage.CreateMessageMock.callArgs = append(mmCreateMessage.CreateMessageMock.callArgs, &mm_params)
	mmCreateMessage.CreateMessageMock.mutex.Unlock()

	for _, e := range mmCreateMessage.CreateMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateMessage.CreateMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateMessage.CreateMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateMessage.CreateMessageMock.defaultExpectation.params
		mm_want_ptrs := mmCreateMessage.CreateMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockCreateMessageParams{ctx, mp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateMessage.t.Errorf("ChatServerRepositoryMock.CreateMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateMessage.CreateMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.mp1 != nil && !minimock.Equal(*mm_want_ptrs.mp1, mm_got.mp1) {
				mmCreateMessage.t.Errorf("ChatServerRepositoryMock.CreateMessage got unexpected parameter mp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateMessage.CreateMessageMock.defaultExpectation.expectationOrigins.originMp1, *mm_want_ptrs.mp1, mm_got.mp1, minimock.Diff(*mm_want_ptrs.mp1, mm_got.mp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateMessage.t.Errorf("ChatServerRepositoryMock.CreateMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateMessage.CreateMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateMessage.CreateMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateMessage.t.Fatal("No results are set for the ChatServerRepositoryMock.CreateMessage")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateMessage.funcCreateMessage != nil {
		return mmCreateMessage.funcCreateMessage(ctx, mp1)
	}
	mmCreateMessage.t.Fatalf("Unexpected call to ChatServerRepositoryMock.CreateMessage. %v %v", ctx, mp1)
	return
}

// CreateMessageAfterCounter returns a count of finished ChatServerRepositoryMock.CreateMessage invocations
func (mmCreateMessage *ChatServerRepositoryMock) CreateMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.afterCreateMessageCounter)
}

// CreateMessageBeforeCounter returns a count of ChatServerRepositoryMock.CreateMessage invocations
func (mmCreateMessage *ChatServerRepositoryMock) CreateMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.beforeCreateMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.CreateMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateMessage *mChatServerRepositoryMockCreateMessage) Calls() []*ChatServerRepositoryMockCreateMessageParams {
	mmCreateMessage.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockCreateMessageParams, len(mmCreateMessage.callArgs))
	copy(argCopy, mmCreateMessage.callArgs)

	mmCreateMessage.mutex.RUnlock()

	return argCopy
}

// MinimockCreateMessageDone returns true if the count of the CreateMessage invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockCreateMessageDone() bool {
	if m.CreateMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMessageMock.invocationsDone()
}

// MinimockCreateMessageInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockCreateMessageInspect() {
	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateMessageCounter := mm_atomic.LoadUint64(&m.afterCreateMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMessageMock.defaultExpectation != nil && afterCreateMessageCounter < 1 {
		if m.CreateMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateMessage at\n%s", m.CreateMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateMessage at\n%s with params: %#v", m.CreateMessageMock.defaultExpectation.expectationOrigins.origin, *m.CreateMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateMessage != nil && afterCreateMessageCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateMessage at\n%s", m.funcCreateMessageOrigin)
	}

	if !m.CreateMessageMock.invocationsDone() && afterCreateMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.CreateMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMessageMock.expectedInvocations), m.CreateMessageMock.expectedInvocationsOrigin, afterCreateMessageCounter)
	}
}

type mChatServerRepositoryMockDeleteChat struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockDeleteChatExpectation
	expectations       []*ChatServerRepositoryMockDeleteChatExpectation

	callArgs []*ChatServerRepositoryMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockDeleteChatExpectation specifies expectation struct of the ChatServerRepository.DeleteChat
type ChatServerRepositoryMockDeleteChatExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockDeleteChatParams
	paramPtrs          *ChatServerRepositoryMockDeleteChatParamPtrs
	expectationOrigins ChatServerRepositoryMockDeleteChatExpectationOrigins
	results            *ChatServerRepositoryMockDeleteChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockDeleteChatParams contains parameters of the ChatServerRepository.DeleteChat
type ChatServerRepositoryMockDeleteChatParams struct {
	ctx context.Context
	i1  int
}

// ChatServerRepositoryMockDeleteChatParamPtrs contains pointers to parameters of the ChatServerRepository.DeleteChat
type ChatServerRepositoryMockDeleteChatParamPtrs struct {
	ctx *context.Context
	i1  *int
}

// ChatServerRepositoryMockDeleteChatResults contains results of the ChatServerRepository.DeleteChat
type ChatServerRepositoryMockDeleteChatResults struct {
	err error
}

// ChatServerRepositoryMockDeleteChatOrigins contains origins of expectations of the ChatServerRepository.DeleteChat
type ChatServerRepositoryMockDeleteChatExpectationOrigins struct {
	origin    string
	originCtx string
	originI1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Optional() *mChatServerRepositoryMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for ChatServerRepository.DeleteChat
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Expect(ctx context.Context, i1 int) *mChatServerRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServerRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &ChatServerRepositoryMockDeleteChatParams{ctx, i1}
	mmDeleteChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.DeleteChat
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServerRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatServerRepositoryMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteChat
}

// ExpectI1Param2 sets up expected param i1 for ChatServerRepository.DeleteChat
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) ExpectI1Param2(i1 int) *mChatServerRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServerRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatServerRepositoryMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.i1 = &i1
	mmDeleteChat.defaultExpectation.expectationOrigins.originI1 = minimock.CallerInfo(1)

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.DeleteChat
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Inspect(f func(ctx context.Context, i1 int)) *mChatServerRepositoryMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatServerRepository.DeleteChat
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Return(err error) *ChatServerRepositoryMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServerRepositoryMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatServerRepositoryMockDeleteChatResults{err}
	mmDeleteChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatServerRepository.DeleteChat method
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Set(f func(ctx context.Context, i1 int) (err error)) *ChatServerRepositoryMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	mmDeleteChat.mock.funcDeleteChatOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// When sets expectation for the ChatServerRepository.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) When(ctx context.Context, i1 int) *ChatServerRepositoryMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockDeleteChatExpectation{
		mock:               mmDeleteChat.mock,
		params:             &ChatServerRepositoryMockDeleteChatParams{ctx, i1},
		expectationOrigins: ChatServerRepositoryMockDeleteChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockDeleteChatExpectation) Then(err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockDeleteChatResults{err}
	return e.mock
}

// Times sets number of times ChatServerRepository.DeleteChat should be invoked
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Times(n uint64) *mChatServerRepositoryMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of ChatServerRepositoryMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	mmDeleteChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteChat
}

func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements mm_repository.ChatServerRepository
func (mmDeleteChat *ChatServerRepositoryMock) DeleteChat(ctx context.Context, i1 int) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	mmDeleteChat.t.Helper()

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, i1)
	}

	mm_params := ChatServerRepositoryMockDeleteChatParams{ctx, i1}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockDeleteChatParams{ctx, i1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("ChatServerRepositoryMock.DeleteChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmDeleteChat.t.Errorf("ChatServerRepositoryMock.DeleteChat got unexpected parameter i1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originI1, *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatServerRepositoryMock.DeleteChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatServerRepositoryMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, i1)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatServerRepositoryMock.DeleteChat. %v %v", ctx, i1)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatServerRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatServerRepositoryMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatServerRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatServerRepositoryMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Calls() []*ChatServerRepositoryMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChat at\n%s", m.DeleteChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChat at\n%s with params: %#v", m.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChat at\n%s", m.funcDeleteChatOrigin)
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.DeleteChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), m.DeleteChatMock.expectedInvocationsOrigin, afterDeleteChatCounter)
	}
}

type mChatServerRepositoryMockDeleteChatMember struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockDeleteChatMemberExpectation
	expectations       []*ChatServerRepositoryMockDeleteChatMemberExpectation

	callArgs []*ChatServerRepositoryMockDeleteChatMemberParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockDeleteChatMemberExpectation specifies expectation struct of the ChatServerRepository.DeleteChatMember
type ChatServerRepositoryMockDeleteChatMemberExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockDeleteChatMemberParams
	paramPtrs          *ChatServerRepositoryMockDeleteChatMemberParamPtrs
	expectationOrigins ChatServerRepositoryMockDeleteChatMemberExpectationOrigins
	results            *ChatServerRepositoryMockDeleteChatMemberResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockDeleteChatMemberParams contains parameters of the ChatServerRepository.DeleteChatMember
type ChatServerRepositoryMockDeleteChatMemberParams struct {
	ctx context.Context
	cp1 *model.ChatMember
}

// ChatServerRepositoryMockDeleteChatMemberParamPtrs contains pointers to parameters of the ChatServerRepository.DeleteChatMember
type ChatServerRepositoryMockDeleteChatMemberParamPtrs struct {
	ctx *context.Context
	cp1 **model.ChatMember
}

// ChatServerRepositoryMockDeleteChatMemberResults contains results of the ChatServerRepository.DeleteChatMember
type ChatServerRepositoryMockDeleteChatMemberResults struct {
	err error
}

// ChatServerRepositoryMockDeleteChatMemberOrigins contains origins of expectations of the ChatServerRepository.DeleteChatMember
type ChatServerRepositoryMockDeleteChatMemberExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChatMember *mChatServerRepositoryMockDeleteChatMember) Optional() *mChatServerRepositoryMockDeleteChatMember {
	mmDeleteChatMember.optional = true
	return mmDeleteChatMember
}

// Expect sets up expected params for ChatServerRepository.DeleteChatMember
func (mmDeleteChatMember *mChatServerRepositoryMockDeleteChatMember) Expect(ctx context.Context, cp1 *model.ChatMember) *mChatServerRepositoryMockDeleteChatMember {
	if mmDeleteChatMember.mock.funcDeleteChatMember != nil {
		mmDeleteChatMember.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatMember mock is already set by Set")
	}

	if mmDeleteChatMember.defaultExpectation == nil {
		mmDeleteChatMember.defaultExpectation = &ChatServerRepositoryMockDeleteChatMemberExpectation{}
	}

	if mmDeleteChatMember.defaultExpectation.paramPtrs != nil {
		mmDeleteChatMember.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatMember mock is already set by ExpectParams functions")
	}

	mmDeleteChatMember.defaultExpectation.params = &ChatServerRepositoryMockDeleteChatMemberParams{ctx, cp1}
	mmDeleteChatMember.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteChatMember.expectations {
		if minimock.Equal(e.params, mmDeleteChatMember.defaultExpectation.params) {
			mmDeleteChatMember.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChatMember.defaultExpectation.params)
		}
	}

	return mmDeleteChatMember
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.DeleteChatMember
func (mmDeleteChatMember *mChatServerRepositoryMockDeleteChatMember) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockDeleteChatMember {
	if mmDeleteChatMember.mock.funcDeleteChatMember != nil {
		mmDeleteChatMember.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatMember mock is already set by Set")
	}

	if mmDeleteChatMember.defaultExpectation == nil {
		mmDeleteChatMember.defaultExpectation = &ChatServerRepositoryMockDeleteChatMemberExpectation{}
	}

	if mmDeleteChatMember.defaultExpectation.params != nil {
		mmDeleteChatMember.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatMember mock is already set by Expect")
	}

	if mmDeleteChatMember.defaultExpectation.paramPtrs == nil {
		mmDeleteChatMember.defaultExpectation.paramPtrs = &ChatServerRepositoryMockDeleteChatMemberParamPtrs{}
	}
	mmDeleteChatMember.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteChatMember.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteChatMember
}

// ExpectCp1Param2 sets up expected param cp1 for ChatServerRepository.DeleteChatMember
func (mmDeleteChatMember *mChatServerRepositoryMockDeleteChatMember) ExpectCp1Param2(cp1 *model.ChatMember) *mChatServerRepositoryMockDeleteChatMember {
	if mmDeleteChatMember.mock.funcDeleteChatMember != nil {
		mmDeleteChatMember.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatMember mock is already set by Set")
	}

	if mmDeleteChatMember.defaultExpectation == nil {
		mmDeleteChatMember.defaultExpectation = &ChatServerRepositoryMockDeleteChatMemberExpectation{}
	}

	if mmDeleteChatMember.defaultExpectation.params != nil {
		mmDeleteChatMember.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatMember mock is already set by Expect")
	}

	if mmDeleteChatMember.defaultExpectation.paramPtrs == nil {
		mmDeleteChatMember.defaultExpectation.paramPtrs = &ChatServerRepositoryMockDeleteChatMemberParamPtrs{}
	}
	mmDeleteChatMember.defaultExpectation.paramPtrs.cp1 = &cp1
	mmDeleteChatMember.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmDeleteChatMember
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.DeleteChatMember
func (mmDeleteChatMember *mChatServerRepositoryMockDeleteChatMember) Inspect(f func(ctx context.Context, cp1 *model.ChatMember)) *mChatServerRepositoryMockDeleteChatMember {
	if mmDeleteChatMember.mock.inspectFuncDeleteChatMember != nil {
		mmDeleteChatMember.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.DeleteChatMember")
	}

	mmDeleteChatMember.mock.inspectFuncDeleteChatMember = f

	return mmDeleteChatMember
}

// Return sets up results that will be returned by ChatServerRepository.DeleteChatMember
func (mmDeleteChatMember *mChatServerRepositoryMockDeleteChatMember) Return(err error) *ChatServerRepositoryMock {
	if mmDeleteChatMember.mock.funcDeleteChatMember != nil {
		mmDeleteChatMember.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatMember mock is already set by Set")
	}

	if mmDeleteChatMember.defaultExpectation == nil {
		mmDeleteChatMember.defaultExpectation = &ChatServerRepositoryMockDeleteChatMemberExpectation{mock: mmDeleteChatMember.mock}
	}
	mmDeleteChatMember.defaultExpectation.results = &ChatServerRepositoryMockDeleteChatMemberResults{err}
	mmDeleteChatMember.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteChatMember.mock
}

// Set uses given function f to mock the ChatServerRepository.DeleteChatMember method
func (mmDeleteChatMember *mChatServerRepositoryMockDeleteChatMember) Set(f func(ctx context.Context, cp1 *model.ChatMember) (err error)) *ChatServerRepositoryMock {
	if mmDeleteChatMember.defaultExpectation != nil {
		mmDeleteChatMember.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.DeleteChatMember method")
	}

	if len(mmDeleteChatMember.expectations) > 0 {
		mmDeleteChatMember.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.DeleteChatMember method")
	}

	mmDeleteChatMember.mock.funcDeleteChatMember = f
	mmDeleteChatMember.mock.funcDeleteChatMemberOrigin = minimock.CallerInfo(1)
	return mmDeleteChatMember.mock
}

// When sets expectation for the ChatServerRepository.DeleteChatMember which will trigger the result defined by the following
// Then helper
func (mmDeleteChatMember *mChatServerRepositoryMockDeleteChatMember) When(ctx context.Context, cp1 *model.ChatMember) *ChatServerRepositoryMockDeleteChatMemberExpectation {
	if mmDeleteChatMember.mock.funcDeleteChatMember != nil {
		mmDeleteChatMember.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatMember mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockDeleteChatMemberExpectation{
		mock:               mmDeleteChatMember.mock,
		params:             &ChatServerRepositoryMockDeleteChatMemberParams{ctx, cp1},
		expectationOrigins: ChatServerRepositoryMockDeleteChatMemberExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteChatMember.expectations = append(mmDeleteChatMember.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.DeleteChatMember return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockDeleteChatMemberExpectation) Then(err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockDeleteChatMemberResults{err}
	return e.mock
}

// Times sets number of times ChatServerRepository.DeleteChatMember should be invoked
func (mmDeleteChatMember *mChatServerRepositoryMockDeleteChatMember) Times(n uint64) *mChatServerRepositoryMockDeleteChatMember {
	if n == 0 {
		mmDeleteChatMember.mock.t.Fatalf("Times of ChatServerRepositoryMock.DeleteChatMember mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChatMember.expectedInvocations, n)
	mmDeleteChatMember.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteChatMember
}

func (mmDeleteChatMember *mChatServerRepositoryMockDeleteChatMember) invocationsDone() bool {
	if len(mmDeleteChatMember.expectations) == 0 && mmDeleteChatMember.defaultExpectation == nil && mmDeleteChatMember.mock.funcDeleteChatMember == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChatMember.mock.afterDeleteChatMemberCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChatMember.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChatMember implements mm_repository.ChatServerRepository
func (mmDeleteChatMember *ChatServerRepositoryMock) DeleteChatMember(ctx context.Context, cp1 *model.ChatMember) (err error) {
	mm_atomic.AddUint64(&mmDeleteChatMember.beforeDeleteChatMemberCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChatMember.afterDeleteChatMemberCounter, 1)

	mmDeleteChatMember.t.Helper()

	if mmDeleteChatMember.inspectFuncDeleteChatMember != nil {
		mmDeleteChatMember.inspectFuncDeleteChatMember(ctx, cp1)
	}

	mm_params := ChatServerRepositoryMockDeleteChatMemberParams{ctx, cp1}

	// Record call args
	mmDeleteChatMember.DeleteChatMemberMock.mutex.Lock()
	mmDeleteChatMember.DeleteChatMemberMock.callArgs = append(mmDeleteChatMember.DeleteChatMemberMock.callArgs, &mm_params)
	mmDeleteChatMember.DeleteChatMemberMock.mutex.Unlock()

	for _, e := range mmDeleteChatMember.DeleteChatMemberMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChatMember.DeleteChatMemberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChatMember.DeleteChatMemberMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChatMember.DeleteChatMemberMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChatMember.DeleteChatMemberMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockDeleteChatMemberParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChatMember.t.Errorf("ChatServerRepositoryMock.DeleteChatMember got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChatMember.DeleteChatMemberMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmDeleteChatMember.t.Errorf("ChatServerRepositoryMock.DeleteChatMember got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChatMember.DeleteChatMemberMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChatMember.t.Errorf("ChatServerRepositoryMock.DeleteChatMember got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteChatMember.DeleteChatMemberMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChatMember.DeleteChatMemberMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChatMember.t.Fatal("No results are set for the ChatServerRepositoryMock.DeleteChatMember")
		}
		return (*mm_results).err
	}
	if mmDeleteChatMember.funcDeleteChatMember != nil {
		return mmDeleteChatMember.funcDeleteChatMember(ctx, cp1)
	}
	mmDeleteChatMember.t.Fatalf("Unexpected call to ChatServerRepositoryMock.DeleteChatMember. %v %v", ctx, cp1)
	return
}

// DeleteChatMemberAfterCounter returns a count of finished ChatServerRepositoryMock.DeleteChatMember invocations
func (mmDeleteChatMember *ChatServerRepositoryMock) DeleteChatMemberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChatMember.afterDeleteChatMemberCounter)
}

// DeleteChatMemberBeforeCounter returns a count of ChatServerRepositoryMock.DeleteChatMember invocations
func (mmDeleteChatMember *ChatServerRepositoryMock) DeleteChatMemberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChatMember.beforeDeleteChatMemberCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.DeleteChatMember.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChatMember *mChatServerRepositoryMockDeleteChatMember) Calls() []*ChatServerRepositoryMockDeleteChatMemberParams {
	mmDeleteChatMember.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockDeleteChatMemberParams, len(mmDeleteChatMember.callArgs))
	copy(argCopy, mmDeleteChatMember.callArgs)

	mmDeleteChatMember.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatMemberDone returns true if the count of the DeleteChatMember invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockDeleteChatMemberDone() bool {
	if m.DeleteChatMemberMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMemberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMemberMock.invocationsDone()
}

// MinimockDeleteChatMemberInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockDeleteChatMemberInspect() {
	for _, e := range m.DeleteChatMemberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChatMember at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteChatMemberCounter := mm_atomic.LoadUint64(&m.afterDeleteChatMemberCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMemberMock.defaultExpectation != nil && afterDeleteChatMemberCounter < 1 {
		if m.DeleteChatMemberMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChatMember at\n%s", m.DeleteChatMemberMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChatMember at\n%s with params: %#v", m.DeleteChatMemberMock.defaultExpectation.expectationOrigins.origin, *m.DeleteChatMemberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChatMember != nil && afterDeleteChatMemberCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChatMember at\n%s", m.funcDeleteChatMemberOrigin)
	}

	if !m.DeleteChatMemberMock.invocationsDone() && afterDeleteChatMemberCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.DeleteChatMember at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMemberMock.expectedInvocations), m.DeleteChatMemberMock.expectedInvocationsOrigin, afterDeleteChatMemberCounter)
	}
}

type mChatServerRepositoryMockDeleteMessage struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockDeleteMessageExpectation
	expectations       []*ChatServerRepositoryMockDeleteMessageExpectation

	callArgs []*ChatServerRepositoryMockDeleteMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockDeleteMessageExpectation specifies expectation struct of the ChatServerRepository.DeleteMessage
type ChatServerRepositoryMockDeleteMessageExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockDeleteMessageParams
	paramPtrs          *ChatServerRepositoryMockDeleteMessageParamPtrs
	expectationOrigins ChatServerRepositoryMockDeleteMessageExpectationOrigins
	results            *ChatServerRepositoryMockDeleteMessageResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockDeleteMessageParams contains parameters of the ChatServerRepository.DeleteMessage
type ChatServerRepositoryMockDeleteMessageParams struct {
	ctx context.Context
	i1  int
}

// ChatServerRepositoryMockDeleteMessageParamPtrs contains pointers to parameters of the ChatServerRepository.DeleteMessage
type ChatServerRepositoryMockDeleteMessageParamPtrs struct {
	ctx *context.Context
	i1  *int
}

// ChatServerRepositoryMockDeleteMessageResults contains results of the ChatServerRepository.DeleteMessage
type ChatServerRepositoryMockDeleteMessageResults struct {
	err error
}

// ChatServerRepositoryMockDeleteMessageOrigins contains origins of expectations of the ChatServerRepository.DeleteMessage
type ChatServerRepositoryMockDeleteMessageExpectationOrigins struct {
	origin    string
	originCtx string
	originI1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteMessage *mChatServerRepositoryMockDeleteMessage) Optional() *mChatServerRepositoryMockDeleteMessage {
	mmDeleteMessage.optional = true
	return mmDeleteMessage
}

// Expect sets up expected params for ChatServerRepository.DeleteMessage
func (mmDeleteMessage *mChatServerRepositoryMockDeleteMessage) Expect(ctx context.Context, i1 int) *mChatServerRepositoryMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatServerRepositoryMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &ChatServerRepositoryMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatServerRepositoryMock.DeleteMessage mock is already set by ExpectParams functions")
	}

	mmDeleteMessage.defaultExpectation.params = &ChatServerRepositoryMockDeleteMessageParams{ctx, i1}
	mmDeleteMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteMessage.expectations {
		if minimock.Equal(e.params, mmDeleteMessage.defaultExpectation.params) {
			mmDeleteMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteMessage.defaultExpectation.params)
		}
	}

	return mmDeleteMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.DeleteMessage
func (mmDeleteMessage *mChatServerRepositoryMockDeleteMessage) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatServerRepositoryMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &ChatServerRepositoryMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.params != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatServerRepositoryMock.DeleteMessage mock is already set by Expect")
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs == nil {
		mmDeleteMessage.defaultExpectation.paramPtrs = &ChatServerRepositoryMockDeleteMessageParamPtrs{}
	}
	mmDeleteMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteMessage
}

// ExpectI1Param2 sets up expected param i1 for ChatServerRepository.DeleteMessage
func (mmDeleteMessage *mChatServerRepositoryMockDeleteMessage) ExpectI1Param2(i1 int) *mChatServerRepositoryMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatServerRepositoryMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &ChatServerRepositoryMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.params != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatServerRepositoryMock.DeleteMessage mock is already set by Expect")
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs == nil {
		mmDeleteMessage.defaultExpectation.paramPtrs = &ChatServerRepositoryMockDeleteMessageParamPtrs{}
	}
	mmDeleteMessage.defaultExpectation.paramPtrs.i1 = &i1
	mmDeleteMessage.defaultExpectation.expectationOrigins.originI1 = minimock.CallerInfo(1)

	return mmDeleteMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.DeleteMessage
func (mmDeleteMessage *mChatServerRepositoryMockDeleteMessage) Inspect(f func(ctx context.Context, i1 int)) *mChatServerRepositoryMockDeleteMessage {
	if mmDeleteMessage.mock.inspectFuncDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.DeleteMessage")
	}

	mmDeleteMessage.mock.inspectFuncDeleteMessage = f

	return mmDeleteMessage
}

// Return sets up results that will be returned by ChatServerRepository.DeleteMessage
func (mmDeleteMessage *mChatServerRepositoryMockDeleteMessage) Return(err error) *ChatServerRepositoryMock {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatServerRepositoryMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &ChatServerRepositoryMockDeleteMessageExpectation{mock: mmDeleteMessage.mock}
	}
	mmDeleteMessage.defaultExpectation.results = &ChatServerRepositoryMockDeleteMessageResults{err}
	mmDeleteMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteMessage.mock
}

// Set uses given function f to mock the ChatServerRepository.DeleteMessage method
func (mmDeleteMessage *mChatServerRepositoryMockDeleteMessage) Set(f func(ctx context.Context, i1 int) (err error)) *ChatServerRepositoryMock {
	if mmDeleteMessage.defaultExpectation != nil {
		mmDeleteMessage.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.DeleteMessage method")
	}

	if len(mmDeleteMessage.expectations) > 0 {
		mmDeleteMessage.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.DeleteMessage method")
	}

	mmDeleteMessage.mock.funcDeleteMessage = f
	mmDeleteMessage.mock.funcDeleteMessageOrigin = minimock.CallerInfo(1)
	return mmDeleteMessage.mock
}

// When sets expectation for the ChatServerRepository.DeleteMessage which will trigger the result defined by the following
// Then helper
func (mmDeleteMessage *mChatServerRepositoryMockDeleteMessage) When(ctx context.Context, i1 int) *ChatServerRepositoryMockDeleteMessageExpectation {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("ChatServerRepositoryMock.DeleteMessage mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockDeleteMessageExpectation{
		mock:               mmDeleteMessage.mock,
		params:             &ChatServerRepositoryMockDeleteMessageParams{ctx, i1},
		expectationOrigins: ChatServerRepositoryMockDeleteMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteMessage.expectations = append(mmDeleteMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.DeleteMessage return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockDeleteMessageExpectation) Then(err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockDeleteMessageResults{err}
	return e.mock
}

// Times sets number of times ChatServerRepository.DeleteMessage should be invoked
func (mmDeleteMessage *mChatServerRepositoryMockDeleteMessage) Times(n uint64) *mChatServerRepositoryMockDeleteMessage {
	if n == 0 {
		mmDeleteMessage.mock.t.Fatalf("Times of ChatServerRepositoryMock.DeleteMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteMessage.expectedInvocations, n)
	mmDeleteMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteMessage
}

func (mmDeleteMessage *mChatServerRepositoryMockDeleteMessage) invocationsDone() bool {
	if len(mmDeleteMessage.expectations) == 0 && mmDeleteMessage.defaultExpectation == nil && mmDeleteMessage.mock.funcDeleteMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteMessage.mock.afterDeleteMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteMessage implements mm_repository.ChatServerRepository
func (mmDeleteMessage *ChatServerRepositoryMock) DeleteMessage(ctx context.Context, i1 int) (err error) {
	mm_atomic.AddUint64(&mmDeleteMessage.beforeDeleteMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteMessage.afterDeleteMessageCounter, 1)

	mmDeleteMessage.t.Helper()

	if mmDeleteMessage.inspectFuncDeleteMessage != nil {
		mmDeleteMessage.inspectFuncDeleteMessage(ctx, i1)
	}

	mm_params := ChatServerRepositoryMockDeleteMessageParams{ctx, i1}

	// Record call args
	mmDeleteMessage.DeleteMessageMock.mutex.Lock()
	mmDeleteMessage.DeleteMessageMock.callArgs = append(mmDeleteMessage.DeleteMessageMock.callArgs, &mm_params)
	mmDeleteMessage.DeleteMessageMock.mutex.Unlock()

	for _, e := range mmDeleteMessage.DeleteMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteMessage.DeleteMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteMessage.DeleteMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteMessage.DeleteMessageMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteMessage.DeleteMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockDeleteMessageParams{ctx, i1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteMessage.t.Errorf("ChatServerRepositoryMock.DeleteMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteMessage.DeleteMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmDeleteMessage.t.Errorf("ChatServerRepositoryMock.DeleteMessage got unexpected parameter i1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteMessage.DeleteMessageMock.defaultExpectation.expectationOrigins.originI1, *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteMessage.t.Errorf("ChatServerRepositoryMock.DeleteMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteMessage.DeleteMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteMessage.DeleteMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteMessage.t.Fatal("No results are set for the ChatServerRepositoryMock.DeleteMessage")
		}
		return (*mm_results).err
	}
	if mmDeleteMessage.funcDeleteMessage != nil {
		return mmDeleteMessage.funcDeleteMessage(ctx, i1)
	}
	mmDeleteMessage.t.Fatalf("Unexpected call to ChatServerRepositoryMock.DeleteMessage. %v %v", ctx, i1)
	return
}

// DeleteMessageAfterCounter returns a count of finished ChatServerRepositoryMock.DeleteMessage invocations
func (mmDeleteMessage *ChatServerRepositoryMock) DeleteMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessage.afterDeleteMessageCounter)
}

// DeleteMessageBeforeCounter returns a count of ChatServerRepositoryMock.DeleteMessage invocations
func (mmDeleteMessage *ChatServerRepositoryMock) DeleteMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessage.beforeDeleteMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.DeleteMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteMessage *mChatServerRepositoryMockDeleteMessage) Calls() []*ChatServerRepositoryMockDeleteMessageParams {
	mmDeleteMessage.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockDeleteMessageParams, len(mmDeleteMessage.callArgs))
	copy(argCopy, mmDeleteMessage.callArgs)

	mmDeleteMessage.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteMessageDone returns true if the count of the DeleteMessage invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockDeleteMessageDone() bool {
	if m.DeleteMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMessageMock.invocationsDone()
}

// MinimockDeleteMessageInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockDeleteMessageInspect() {
	for _, e := range m.DeleteMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteMessageCounter := mm_atomic.LoadUint64(&m.afterDeleteMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMessageMock.defaultExpectation != nil && afterDeleteMessageCounter < 1 {
		if m.DeleteMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteMessage at\n%s", m.DeleteMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteMessage at\n%s with params: %#v", m.DeleteMessageMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMessage != nil && afterDeleteMessageCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteMessage at\n%s", m.funcDeleteMessageOrigin)
	}

	if !m.DeleteMessageMock.invocationsDone() && afterDeleteMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.DeleteMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMessageMock.expectedInvocations), m.DeleteMessageMock.expectedInvocationsOrigin, afterDeleteMessageCounter)
	}
}

type mChatServerRepositoryMockReadChat struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockReadChatExpectation
	expectations       []*ChatServerRepositoryMockReadChatExpectation

	callArgs []*ChatServerRepositoryMockReadChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockReadChatExpectation specifies expectation struct of the ChatServerRepository.ReadChat
type ChatServerRepositoryMockReadChatExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockReadChatParams
	paramPtrs          *ChatServerRepositoryMockReadChatParamPtrs
	expectationOrigins ChatServerRepositoryMockReadChatExpectationOrigins
	results            *ChatServerRepositoryMockReadChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockReadChatParams contains parameters of the ChatServerRepository.ReadChat
type ChatServerRepositoryMockReadChatParams struct {
	ctx context.Context
	i1  int
}

// ChatServerRepositoryMockReadChatParamPtrs contains pointers to parameters of the ChatServerRepository.ReadChat
type ChatServerRepositoryMockReadChatParamPtrs struct {
	ctx *context.Context
	i1  *int
}

// ChatServerRepositoryMockReadChatResults contains results of the ChatServerRepository.ReadChat
type ChatServerRepositoryMockReadChatResults struct {
	cp1 *model.Chat
	err error
}

// ChatServerRepositoryMockReadChatOrigins contains origins of expectations of the ChatServerRepository.ReadChat
type ChatServerRepositoryMockReadChatExpectationOrigins struct {
	origin    string
	originCtx string
	originI1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadChat *mChatServerRepositoryMockReadChat) Optional() *mChatServerRepositoryMockReadChat {
	mmReadChat.optional = true
	return mmReadChat
}

// Expect sets up expected params for ChatServerRepository.ReadChat
func (mmReadChat *mChatServerRepositoryMockReadChat) Expect(ctx context.Context, i1 int) *mChatServerRepositoryMockReadChat {
	if mmReadChat.mock.funcReadChat != nil {
		mmReadChat.mock.t.Fatalf("ChatServerRepositoryMock.ReadChat mock is already set by Set")
	}

	if mmReadChat.defaultExpectation == nil {
		mmReadChat.defaultExpectation = &ChatServerRepositoryMockReadChatExpectation{}
	}

	if mmReadChat.defaultExpectation.paramPtrs != nil {
		mmReadChat.mock.t.Fatalf("ChatServerRepositoryMock.ReadChat mock is already set by ExpectParams functions")
	}

	mmReadChat.defaultExpectation.params = &ChatServerRepositoryMockReadChatParams{ctx, i1}
	mmReadChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadChat.expectations {
		if minimock.Equal(e.params, mmReadChat.defaultExpectation.params) {
			mmReadChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadChat.defaultExpectation.params)
		}
	}

	return mmReadChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.ReadChat
func (mmReadChat *mChatServerRepositoryMockReadChat) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockReadChat {
	if mmReadChat.mock.funcReadChat != nil {
		mmReadChat.mock.t.Fatalf("ChatServerRepositoryMock.ReadChat mock is already set by Set")
	}

	if mmReadChat.defaultExpectation == nil {
		mmReadChat.defaultExpectation = &ChatServerRepositoryMockReadChatExpectation{}
	}

	if mmReadChat.defaultExpectation.params != nil {
		mmReadChat.mock.t.Fatalf("ChatServerRepositoryMock.ReadChat mock is already set by Expect")
	}

	if mmReadChat.defaultExpectation.paramPtrs == nil {
		mmReadChat.defaultExpectation.paramPtrs = &ChatServerRepositoryMockReadChatParamPtrs{}
	}
	mmReadChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadChat
}

// ExpectI1Param2 sets up expected param i1 for ChatServerRepository.ReadChat
func (mmReadChat *mChatServerRepositoryMockReadChat) ExpectI1Param2(i1 int) *mChatServerRepositoryMockReadChat {
	if mmReadChat.mock.funcReadChat != nil {
		mmReadChat.mock.t.Fatalf("ChatServerRepositoryMock.ReadChat mock is already set by Set")
	}

	if mmReadChat.defaultExpectation == nil {
		mmReadChat.defaultExpectation = &ChatServerRepositoryMockReadChatExpectation{}
	}

	if mmReadChat.defaultExpectation.params != nil {
		mmReadChat.mock.t.Fatalf("ChatServerRepositoryMock.ReadChat mock is already set by Expect")
	}

	if mmReadChat.defaultExpectation.paramPtrs == nil {
		mmReadChat.defaultExpectation.paramPtrs = &ChatServerRepositoryMockReadChatParamPtrs{}
	}
	mmReadChat.defaultExpectation.paramPtrs.i1 = &i1
	mmReadChat.defaultExpectation.expectationOrigins.originI1 = minimock.CallerInfo(1)

	return mmReadChat
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.ReadChat
func (mmReadChat *mChatServerRepositoryMockReadChat) Inspect(f func(ctx context.Context, i1 int)) *mChatServerRepositoryMockReadChat {
	if mmReadChat.mock.inspectFuncReadChat != nil {
		mmReadChat.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.ReadChat")
	}

	mmReadChat.mock.inspectFuncReadChat = f

	return mmReadChat
}

// Return sets up results that will be returned by ChatServerRepository.ReadChat
func (mmReadChat *mChatServerRepositoryMockReadChat) Return(cp1 *model.Chat, err error) *ChatServerRepositoryMock {
	if mmReadChat.mock.funcReadChat != nil {
		mmReadChat.mock.t.Fatalf("ChatServerRepositoryMock.ReadChat mock is already set by Set")
	}

	if mmReadChat.defaultExpectation == nil {
		mmReadChat.defaultExpectation = &ChatServerRepositoryMockReadChatExpectation{mock: mmReadChat.mock}
	}
	mmReadChat.defaultExpectation.results = &ChatServerRepositoryMockReadChatResults{cp1, err}
	mmReadChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadChat.mock
}

// Set uses given function f to mock the ChatServerRepository.ReadChat method
func (mmReadChat *mChatServerRepositoryMockReadChat) Set(f func(ctx context.Context, i1 int) (cp1 *model.Chat, err error)) *ChatServerRepositoryMock {
	if mmReadChat.defaultExpectation != nil {
		mmReadChat.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.ReadChat method")
	}

	if len(mmReadChat.expectations) > 0 {
		mmReadChat.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.ReadChat method")
	}

	mmReadChat.mock.funcReadChat = f
	mmReadChat.mock.funcReadChatOrigin = minimock.CallerInfo(1)
	return mmReadChat.mock
}

// When sets expectation for the ChatServerRepository.ReadChat which will trigger the result defined by the following
// Then helper
func (mmReadChat *mChatServerRepositoryMockReadChat) When(ctx context.Context, i1 int) *ChatServerRepositoryMockReadChatExpectation {
	if mmReadChat.mock.funcReadChat != nil {
		mmReadChat.mock.t.Fatalf("ChatServerRepositoryMock.ReadChat mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockReadChatExpectation{
		mock:               mmReadChat.mock,
		params:             &ChatServerRepositoryMockReadChatParams{ctx, i1},
		expectationOrigins: ChatServerRepositoryMockReadChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadChat.expectations = append(mmReadChat.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.ReadChat return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockReadChatExpectation) Then(cp1 *model.Chat, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockReadChatResults{cp1, err}
	return e.mock
}

// Times sets number of times ChatServerRepository.ReadChat should be invoked
func (mmReadChat *mChatServerRepositoryMockReadChat) Times(n uint64) *mChatServerRepositoryMockReadChat {
	if n == 0 {
		mmReadChat.mock.t.Fatalf("Times of ChatServerRepositoryMock.ReadChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadChat.expectedInvocations, n)
	mmReadChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadChat
}

func (mmReadChat *mChatServerRepositoryMockReadChat) invocationsDone() bool {
	if len(mmReadChat.expectations) == 0 && mmReadChat.defaultExpectation == nil && mmReadChat.mock.funcReadChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadChat.mock.afterReadChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReadChat implements mm_repository.ChatServerRepository
func (mmReadChat *ChatServerRepositoryMock) ReadChat(ctx context.Context, i1 int) (cp1 *model.Chat, err error) {
	mm_atomic.AddUint64(&mmReadChat.beforeReadChatCounter, 1)
	defer mm_atomic.AddUint64(&mmReadChat.afterReadChatCounter, 1)

	mmReadChat.t.Helper()

	if mmReadChat.inspectFuncReadChat != nil {
		mmReadChat.inspectFuncReadChat(ctx, i1)
	}

	mm_params := ChatServerRepositoryMockReadChatParams{ctx, i1}

	// Record call args
	mmReadChat.ReadChatMock.mutex.Lock()
	mmReadChat.ReadChatMock.callArgs = append(mmReadChat.ReadChatMock.callArgs, &mm_params)
	mmReadChat.ReadChatMock.mutex.Unlock()

	for _, e := range mmReadChat.ReadChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmReadChat.ReadChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadChat.ReadChatMock.defaultExpectation.Counter, 1)
		mm_want := mmReadChat.ReadChatMock.defaultExpectation.params
		mm_want_ptrs := mmReadChat.ReadChatMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockReadChatParams{ctx, i1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadChat.t.Errorf("ChatServerRepositoryMock.ReadChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadChat.ReadChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmReadChat.t.Errorf("ChatServerRepositoryMock.ReadChat got unexpected parameter i1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadChat.ReadChatMock.defaultExpectation.expectationOrigins.originI1, *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadChat.t.Errorf("ChatServerRepositoryMock.ReadChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadChat.ReadChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadChat.ReadChatMock.defaultExpectation.results
		if mm_results == nil {
			mmReadChat.t.Fatal("No results are set for the ChatServerRepositoryMock.ReadChat")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmReadChat.funcReadChat != nil {
		return mmReadChat.funcReadChat(ctx, i1)
	}
	mmReadChat.t.Fatalf("Unexpected call to ChatServerRepositoryMock.ReadChat. %v %v", ctx, i1)
	return
}

// ReadChatAfterCounter returns a count of finished ChatServerRepositoryMock.ReadChat invocations
func (mmReadChat *ChatServerRepositoryMock) ReadChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadChat.afterReadChatCounter)
}

// ReadChatBeforeCounter returns a count of ChatServerRepositoryMock.ReadChat invocations
func (mmReadChat *ChatServerRepositoryMock) ReadChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadChat.beforeReadChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.ReadChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadChat *mChatServerRepositoryMockReadChat) Calls() []*ChatServerRepositoryMockReadChatParams {
	mmReadChat.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockReadChatParams, len(mmReadChat.callArgs))
	copy(argCopy, mmReadChat.callArgs)

	mmReadChat.mutex.RUnlock()

	return argCopy
}

// MinimockReadChatDone returns true if the count of the ReadChat invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockReadChatDone() bool {
	if m.ReadChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadChatMock.invocationsDone()
}

// MinimockReadChatInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockReadChatInspect() {
	for _, e := range m.ReadChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadChatCounter := mm_atomic.LoadUint64(&m.afterReadChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadChatMock.defaultExpectation != nil && afterReadChatCounter < 1 {
		if m.ReadChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChat at\n%s", m.ReadChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChat at\n%s with params: %#v", m.ReadChatMock.defaultExpectation.expectationOrigins.origin, *m.ReadChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadChat != nil && afterReadChatCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChat at\n%s", m.funcReadChatOrigin)
	}

	if !m.ReadChatMock.invocationsDone() && afterReadChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.ReadChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadChatMock.expectedInvocations), m.ReadChatMock.expectedInvocationsOrigin, afterReadChatCounter)
	}
}

type mChatServerRepositoryMockReadChatMember struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockReadChatMemberExpectation
	expectations       []*ChatServerRepositoryMockReadChatMemberExpectation

	callArgs []*ChatServerRepositoryMockReadChatMemberParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockReadChatMemberExpectation specifies expectation struct of the ChatServerRepository.ReadChatMember
type ChatServerRepositoryMockReadChatMemberExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockReadChatMemberParams
	paramPtrs          *ChatServerRepositoryMockReadChatMemberParamPtrs
	expectationOrigins ChatServerRepositoryMockReadChatMemberExpectationOrigins
	results            *ChatServerRepositoryMockReadChatMemberResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockReadChatMemberParams contains parameters of the ChatServerRepository.ReadChatMember
type ChatServerRepositoryMockReadChatMemberParams struct {
	ctx context.Context
	cp1 *model.ChatMember
}

// ChatServerRepositoryMockReadChatMemberParamPtrs contains pointers to parameters of the ChatServerRepository.ReadChatMember
type ChatServerRepositoryMockReadChatMemberParamPtrs struct {
	ctx *context.Context
	cp1 **model.ChatMember
}

// ChatServerRepositoryMockReadChatMemberResults contains results of the ChatServerRepository.ReadChatMember
type ChatServerRepositoryMockReadChatMemberResults struct {
	cp2 *model.ChatMember
	err error
}

// ChatServerRepositoryMockReadChatMemberOrigins contains origins of expectations of the ChatServerRepository.ReadChatMember
type ChatServerRepositoryMockReadChatMemberExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadChatMember *mChatServerRepositoryMockReadChatMember) Optional() *mChatServerRepositoryMockReadChatMember {
	mmReadChatMember.optional = true
	return mmReadChatMember
}

// Expect sets up expected params for ChatServerRepository.ReadChatMember
func (mmReadChatMember *mChatServerRepositoryMockReadChatMember) Expect(ctx context.Context, cp1 *model.ChatMember) *mChatServerRepositoryMockReadChatMember {
	if mmReadChatMember.mock.funcReadChatMember != nil {
		mmReadChatMember.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMember mock is already set by Set")
	}

	if mmReadChatMember.defaultExpectation == nil {
		mmReadChatMember.defaultExpectation = &ChatServerRepositoryMockReadChatMemberExpectation{}
	}

	if mmReadChatMember.defaultExpectation.paramPtrs != nil {
		mmReadChatMember.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMember mock is already set by ExpectParams functions")
	}

	mmReadChatMember.defaultExpectation.params = &ChatServerRepositoryMockReadChatMemberParams{ctx, cp1}
	mmReadChatMember.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadChatMember.expectations {
		if minimock.Equal(e.params, mmReadChatMember.defaultExpectation.params) {
			mmReadChatMember.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadChatMember.defaultExpectation.params)
		}
	}

	return mmReadChatMember
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.ReadChatMember
func (mmReadChatMember *mChatServerRepositoryMockReadChatMember) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockReadChatMember {
	if mmReadChatMember.mock.funcReadChatMember != nil {
		mmReadChatMember.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMember mock is already set by Set")
	}

	if mmReadChatMember.defaultExpectation == nil {
		mmReadChatMember.defaultExpectation = &ChatServerRepositoryMockReadChatMemberExpectation{}
	}

	if mmReadChatMember.defaultExpectation.params != nil {
		mmReadChatMember.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMember mock is already set by Expect")
	}

	if mmReadChatMember.defaultExpectation.paramPtrs == nil {
		mmReadChatMember.defaultExpectation.paramPtrs = &ChatServerRepositoryMockReadChatMemberParamPtrs{}
	}
	mmReadChatMember.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadChatMember.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadChatMember
}

// ExpectCp1Param2 sets up expected param cp1 for ChatServerRepository.ReadChatMember
func (mmReadChatMember *mChatServerRepositoryMockReadChatMember) ExpectCp1Param2(cp1 *model.ChatMember) *mChatServerRepositoryMockReadChatMember {
	if mmReadChatMember.mock.funcReadChatMember != nil {
		mmReadChatMember.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMember mock is already set by Set")
	}

	if mmReadChatMember.defaultExpectation == nil {
		mmReadChatMember.defaultExpectation = &ChatServerRepositoryMockReadChatMemberExpectation{}
	}

	if mmReadChatMember.defaultExpectation.params != nil {
		mmReadChatMember.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMember mock is already set by Expect")
	}

	if mmReadChatMember.defaultExpectation.paramPtrs == nil {
		mmReadChatMember.defaultExpectation.paramPtrs = &ChatServerRepositoryMockReadChatMemberParamPtrs{}
	}
	mmReadChatMember.defaultExpectation.paramPtrs.cp1 = &cp1
	mmReadChatMember.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmReadChatMember
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.ReadChatMember
func (mmReadChatMember *mChatServerRepositoryMockReadChatMember) Inspect(f func(ctx context.Context, cp1 *model.ChatMember)) *mChatServerRepositoryMockReadChatMember {
	if mmReadChatMember.mock.inspectFuncReadChatMember != nil {
		mmReadChatMember.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.ReadChatMember")
	}

	mmReadChatMember.mock.inspectFuncReadChatMember = f

	return mmReadChatMember
}

// Return sets up results that will be returned by ChatServerRepository.ReadChatMember
func (mmReadChatMember *mChatServerRepositoryMockReadChatMember) Return(cp2 *model.ChatMember, err error) *ChatServerRepositoryMock {
	if mmReadChatMember.mock.funcReadChatMember != nil {
		mmReadChatMember.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMember mock is already set by Set")
	}

	if mmReadChatMember.defaultExpectation == nil {
		mmReadChatMember.defaultExpectation = &ChatServerRepositoryMockReadChatMemberExpectation{mock: mmReadChatMember.mock}
	}
	mmReadChatMember.defaultExpectation.results = &ChatServerRepositoryMockReadChatMemberResults{cp2, err}
	mmReadChatMember.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadChatMember.mock
}

// Set uses given function f to mock the ChatServerRepository.ReadChatMember method
func (mmReadChatMember *mChatServerRepositoryMockReadChatMember) Set(f func(ctx context.Context, cp1 *model.ChatMember) (cp2 *model.ChatMember, err error)) *ChatServerRepositoryMock {
	if mmReadChatMember.defaultExpectation != nil {
		mmReadChatMember.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.ReadChatMember method")
	}

	if len(mmReadChatMember.expectations) > 0 {
		mmReadChatMember.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.ReadChatMember method")
	}

	mmReadChatMember.mock.funcReadChatMember = f
	mmReadChatMember.mock.funcReadChatMemberOrigin = minimock.CallerInfo(1)
	return mmReadChatMember.mock
}

// When sets expectation for the ChatServerRepository.ReadChatMember which will trigger the result defined by the following
// Then helper
func (mmReadChatMember *mChatServerRepositoryMockReadChatMember) When(ctx context.Context, cp1 *model.ChatMember) *ChatServerRepositoryMockReadChatMemberExpectation {
	if mmReadChatMember.mock.funcReadChatMember != nil {
		mmReadChatMember.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMember mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockReadChatMemberExpectation{
		mock:               mmReadChatMember.mock,
		params:             &ChatServerRepositoryMockReadChatMemberParams{ctx, cp1},
		expectationOrigins: ChatServerRepositoryMockReadChatMemberExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadChatMember.expectations = append(mmReadChatMember.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.ReadChatMember return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockReadChatMemberExpectation) Then(cp2 *model.ChatMember, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockReadChatMemberResults{cp2, err}
	return e.mock
}

// Times sets number of times ChatServerRepository.ReadChatMember should be invoked
func (mmReadChatMember *mChatServerRepositoryMockReadChatMember) Times(n uint64) *mChatServerRepositoryMockReadChatMember {
	if n == 0 {
		mmReadChatMember.mock.t.Fatalf("Times of ChatServerRepositoryMock.ReadChatMember mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadChatMember.expectedInvocations, n)
	mmReadChatMember.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadChatMember
}

func (mmReadChatMember *mChatServerRepositoryMockReadChatMember) invocationsDone() bool {
	if len(mmReadChatMember.expectations) == 0 && mmReadChatMember.defaultExpectation == nil && mmReadChatMember.mock.funcReadChatMember == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadChatMember.mock.afterReadChatMemberCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadChatMember.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReadChatMember implements mm_repository.ChatServerRepository
func (mmReadChatMember *ChatServerRepositoryMock) ReadChatMember(ctx context.Context, cp1 *model.ChatMember) (cp2 *model.ChatMember, err error) {
	mm_atomic.AddUint64(&mmReadChatMember.beforeReadChatMemberCounter, 1)
	defer mm_atomic.AddUint64(&mmReadChatMember.afterReadChatMemberCounter, 1)

	mmReadChatMember.t.Helper()

	if mmReadChatMember.inspectFuncReadChatMember != nil {
		mmReadChatMember.inspectFuncReadChatMember(ctx, cp1)
	}

	mm_params := ChatServerRepositoryMockReadChatMemberParams{ctx, cp1}

	// Record call args
	mmReadChatMember.ReadChatMemberMock.mutex.Lock()
	mmReadChatMember.ReadChatMemberMock.callArgs = append(mmReadChatMember.ReadChatMemberMock.callArgs, &mm_params)
	mmReadChatMember.ReadChatMemberMock.mutex.Unlock()

	for _, e := range mmReadChatMember.ReadChatMemberMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmReadChatMember.ReadChatMemberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadChatMember.ReadChatMemberMock.defaultExpectation.Counter, 1)
		mm_want := mmReadChatMember.ReadChatMemberMock.defaultExpectation.params
		mm_want_ptrs := mmReadChatMember.ReadChatMemberMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockReadChatMemberParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadChatMember.t.Errorf("ChatServerRepositoryMock.ReadChatMember got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadChatMember.ReadChatMemberMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmReadChatMember.t.Errorf("ChatServerRepositoryMock.ReadChatMember got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadChatMember.ReadChatMemberMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadChatMember.t.Errorf("ChatServerRepositoryMock.ReadChatMember got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadChatMember.ReadChatMemberMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadChatMember.ReadChatMemberMock.defaultExpectation.results
		if mm_results == nil {
			mmReadChatMember.t.Fatal("No results are set for the ChatServerRepositoryMock.ReadChatMember")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmReadChatMember.funcReadChatMember != nil {
		return mmReadChatMember.funcReadChatMember(ctx, cp1)
	}
	mmReadChatMember.t.Fatalf("Unexpected call to ChatServerRepositoryMock.ReadChatMember. %v %v", ctx, cp1)
	return
}

// ReadChatMemberAfterCounter returns a count of finished ChatServerRepositoryMock.ReadChatMember invocations
func (mmReadChatMember *ChatServerRepositoryMock) ReadChatMemberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadChatMember.afterReadChatMemberCounter)
}

// ReadChatMemberBeforeCounter returns a count of ChatServerRepositoryMock.ReadChatMember invocations
func (mmReadChatMember *ChatServerRepositoryMock) ReadChatMemberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadChatMember.beforeReadChatMemberCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.ReadChatMember.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadChatMember *mChatServerRepositoryMockReadChatMember) Calls() []*ChatServerRepositoryMockReadChatMemberParams {
	mmReadChatMember.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockReadChatMemberParams, len(mmReadChatMember.callArgs))
	copy(argCopy, mmReadChatMember.callArgs)

	mmReadChatMember.mutex.RUnlock()

	return argCopy
}

// MinimockReadChatMemberDone returns true if the count of the ReadChatMember invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockReadChatMemberDone() bool {
	if m.ReadChatMemberMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadChatMemberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadChatMemberMock.invocationsDone()
}

// MinimockReadChatMemberInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockReadChatMemberInspect() {
	for _, e := range m.ReadChatMemberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChatMember at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadChatMemberCounter := mm_atomic.LoadUint64(&m.afterReadChatMemberCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadChatMemberMock.defaultExpectation != nil && afterReadChatMemberCounter < 1 {
		if m.ReadChatMemberMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChatMember at\n%s", m.ReadChatMemberMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChatMember at\n%s with params: %#v", m.ReadChatMemberMock.defaultExpectation.expectationOrigins.origin, *m.ReadChatMemberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadChatMember != nil && afterReadChatMemberCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChatMember at\n%s", m.funcReadChatMemberOrigin)
	}

	if !m.ReadChatMemberMock.invocationsDone() && afterReadChatMemberCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.ReadChatMember at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadChatMemberMock.expectedInvocations), m.ReadChatMemberMock.expectedInvocationsOrigin, afterReadChatMemberCounter)
	}
}

type mChatServerRepositoryMockReadChatMembers struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockReadChatMembersExpectation
	expectations       []*ChatServerRepositoryMockReadChatMembersExpectation

	callArgs []*ChatServerRepositoryMockReadChatMembersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockReadChatMembersExpectation specifies expectation struct of the ChatServerRepository.ReadChatMembers
type ChatServerRepositoryMockReadChatMembersExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockReadChatMembersParams
	paramPtrs          *ChatServerRepositoryMockReadChatMembersParamPtrs
	expectationOrigins ChatServerRepositoryMockReadChatMembersExpectationOrigins
	results            *ChatServerRepositoryMockReadChatMembersResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockReadChatMembersParams contains parameters of the ChatServerRepository.ReadChatMembers
type ChatServerRepositoryMockReadChatMembersParams struct {
	ctx context.Context
	i1  int
}

// ChatServerRepositoryMockReadChatMembersParamPtrs contains pointers to parameters of the ChatServerRepository.ReadChatMembers
type ChatServerRepositoryMockReadChatMembersParamPtrs struct {
	ctx *context.Context
	i1  *int
}

// ChatServerRepositoryMockReadChatMembersResults contains results of the ChatServerRepository.ReadChatMembers
type ChatServerRepositoryMockReadChatMembersResults struct {
	cpa1 []*model.ChatMember
	err  error
}

// ChatServerRepositoryMockReadChatMembersOrigins contains origins of expectations of the ChatServerRepository.ReadChatMembers
type ChatServerRepositoryMockReadChatMembersExpectationOrigins struct {
	origin    string
	originCtx string
	originI1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadChatMembers *mChatServerRepositoryMockReadChatMembers) Optional() *mChatServerRepositoryMockReadChatMembers {
	mmReadChatMembers.optional = true
	return mmReadChatMembers
}

// Expect sets up expected params for ChatServerRepository.ReadChatMembers
func (mmReadChatMembers *mChatServerRepositoryMockReadChatMembers) Expect(ctx context.Context, i1 int) *mChatServerRepositoryMockReadChatMembers {
	if mmReadChatMembers.mock.funcReadChatMembers != nil {
		mmReadChatMembers.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMembers mock is already set by Set")
	}

	if mmReadChatMembers.defaultExpectation == nil {
		mmReadChatMembers.defaultExpectation = &ChatServerRepositoryMockReadChatMembersExpectation{}
	}

	if mmReadChatMembers.defaultExpectation.paramPtrs != nil {
		mmReadChatMembers.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMembers mock is already set by ExpectParams functions")
	}

	mmReadChatMembers.defaultExpectation.params = &ChatServerRepositoryMockReadChatMembersParams{ctx, i1}
	mmReadChatMembers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadChatMembers.expectations {
		if minimock.Equal(e.params, mmReadChatMembers.defaultExpectation.params) {
			mmReadChatMembers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadChatMembers.defaultExpectation.params)
		}
	}

	return mmReadChatMembers
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.ReadChatMembers
func (mmReadChatMembers *mChatServerRepositoryMockReadChatMembers) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockReadChatMembers {
	if mmReadChatMembers.mock.funcReadChatMembers != nil {
		mmReadChatMembers.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMembers mock is already set by Set")
	}

	if mmReadChatMembers.defaultExpectation == nil {
		mmReadChatMembers.defaultExpectation = &ChatServerRepositoryMockReadChatMembersExpectation{}
	}

	if mmReadChatMembers.defaultExpectation.params != nil {
		mmReadChatMembers.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMembers mock is already set by Expect")
	}

	if mmReadChatMembers.defaultExpectation.paramPtrs == nil {
		mmReadChatMembers.defaultExpectation.paramPtrs = &ChatServerRepositoryMockReadChatMembersParamPtrs{}
	}
	mmReadChatMembers.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadChatMembers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadChatMembers
}

// ExpectI1Param2 sets up expected param i1 for ChatServerRepository.ReadChatMembers
func (mmReadChatMembers *mChatServerRepositoryMockReadChatMembers) ExpectI1Param2(i1 int) *mChatServerRepositoryMockReadChatMembers {
	if mmReadChatMembers.mock.funcReadChatMembers != nil {
		mmReadChatMembers.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMembers mock is already set by Set")
	}

	if mmReadChatMembers.defaultExpectation == nil {
		mmReadChatMembers.defaultExpectation = &ChatServerRepositoryMockReadChatMembersExpectation{}
	}

	if mmReadChatMembers.defaultExpectation.params != nil {
		mmReadChatMembers.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMembers mock is already set by Expect")
	}

	if mmReadChatMembers.defaultExpectation.paramPtrs == nil {
		mmReadChatMembers.defaultExpectation.paramPtrs = &ChatServerRepositoryMockReadChatMembersParamPtrs{}
	}
	mmReadChatMembers.defaultExpectation.paramPtrs.i1 = &i1
	mmReadChatMembers.defaultExpectation.expectationOrigins.originI1 = minimock.CallerInfo(1)

	return mmReadChatMembers
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.ReadChatMembers
func (mmReadChatMembers *mChatServerRepositoryMockReadChatMembers) Inspect(f func(ctx context.Context, i1 int)) *mChatServerRepositoryMockReadChatMembers {
	if mmReadChatMembers.mock.inspectFuncReadChatMembers != nil {
		mmReadChatMembers.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.ReadChatMembers")
	}

	mmReadChatMembers.mock.inspectFuncReadChatMembers = f

	return mmReadChatMembers
}

// Return sets up results that will be returned by ChatServerRepository.ReadChatMembers
func (mmReadChatMembers *mChatServerRepositoryMockReadChatMembers) Return(cpa1 []*model.ChatMember, err error) *ChatServerRepositoryMock {
	if mmReadChatMembers.mock.funcReadChatMembers != nil {
		mmReadChatMembers.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMembers mock is already set by Set")
	}

	if mmReadChatMembers.defaultExpectation == nil {
		mmReadChatMembers.defaultExpectation = &ChatServerRepositoryMockReadChatMembersExpectation{mock: mmReadChatMembers.mock}
	}
	mmReadChatMembers.defaultExpectation.results = &ChatServerRepositoryMockReadChatMembersResults{cpa1, err}
	mmReadChatMembers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadChatMembers.mock
}

// Set uses given function f to mock the ChatServerRepository.ReadChatMembers method
func (mmReadChatMembers *mChatServerRepositoryMockReadChatMembers) Set(f func(ctx context.Context, i1 int) (cpa1 []*model.ChatMember, err error)) *ChatServerRepositoryMock {
	if mmReadChatMembers.defaultExpectation != nil {
		mmReadChatMembers.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.ReadChatMembers method")
	}

	if len(mmReadChatMembers.expectations) > 0 {
		mmReadChatMembers.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.ReadChatMembers method")
	}

	mmReadChatMembers.mock.funcReadChatMembers = f
	mmReadChatMembers.mock.funcReadChatMembersOrigin = minimock.CallerInfo(1)
	return mmReadChatMembers.mock
}

// When sets expectation for the ChatServerRepository.ReadChatMembers which will trigger the result defined by the following
// Then helper
func (mmReadChatMembers *mChatServerRepositoryMockReadChatMembers) When(ctx context.Context, i1 int) *ChatServerRepositoryMockReadChatMembersExpectation {
	if mmReadChatMembers.mock.funcReadChatMembers != nil {
		mmReadChatMembers.mock.t.Fatalf("ChatServerRepositoryMock.ReadChatMembers mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockReadChatMembersExpectation{
		mock:               mmReadChatMembers.mock,
		params:             &ChatServerRepositoryMockReadChatMembersParams{ctx, i1},
		expectationOrigins: ChatServerRepositoryMockReadChatMembersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadChatMembers.expectations = append(mmReadChatMembers.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.ReadChatMembers return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockReadChatMembersExpectation) Then(cpa1 []*model.ChatMember, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockReadChatMembersResults{cpa1, err}
	return e.mock
}

// Times sets number of times ChatServerRepository.ReadChatMembers should be invoked
func (mmReadChatMembers *mChatServerRepositoryMockReadChatMembers) Times(n uint64) *mChatServerRepositoryMockReadChatMembers {
	if n == 0 {
		mmReadChatMembers.mock.t.Fatalf("Times of ChatServerRepositoryMock.ReadChatMembers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadChatMembers.expectedInvocations, n)
	mmReadChatMembers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadChatMembers
}

func (mmReadChatMembers *mChatServerRepositoryMockReadChatMembers) invocationsDone() bool {
	if len(mmReadChatMembers.expectations) == 0 && mmReadChatMembers.defaultExpectation == nil && mmReadChatMembers.mock.funcReadChatMembers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadChatMembers.mock.afterReadChatMembersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadChatMembers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReadChatMembers implements mm_repository.ChatServerRepository
func (mmReadChatMembers *ChatServerRepositoryMock) ReadChatMembers(ctx context.Context, i1 int) (cpa1 []*model.ChatMember, err error) {
	mm_atomic.AddUint64(&mmReadChatMembers.beforeReadChatMembersCounter, 1)
	defer mm_atomic.AddUint64(&mmReadChatMembers.afterReadChatMembersCounter, 1)

	mmReadChatMembers.t.Helper()

	if mmReadChatMembers.inspectFuncReadChatMembers != nil {
		mmReadChatMembers.inspectFuncReadChatMembers(ctx, i1)
	}

	mm_params := ChatServerRepositoryMockReadChatMembersParams{ctx, i1}

	// Record call args
	mmReadChatMembers.ReadChatMembersMock.mutex.Lock()
	mmReadChatMembers.ReadChatMembersMock.callArgs = append(mmReadChatMembers.ReadChatMembersMock.callArgs, &mm_params)
	mmReadChatMembers.ReadChatMembersMock.mutex.Unlock()

	for _, e := range mmReadChatMembers.ReadChatMembersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmReadChatMembers.ReadChatMembersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadChatMembers.ReadChatMembersMock.defaultExpectation.Counter, 1)
		mm_want := mmReadChatMembers.ReadChatMembersMock.defaultExpectation.params
		mm_want_ptrs := mmReadChatMembers.ReadChatMembersMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockReadChatMembersParams{ctx, i1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadChatMembers.t.Errorf("ChatServerRepositoryMock.ReadChatMembers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadChatMembers.ReadChatMembersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmReadChatMembers.t.Errorf("ChatServerRepositoryMock.ReadChatMembers got unexpected parameter i1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadChatMembers.ReadChatMembersMock.defaultExpectation.expectationOrigins.originI1, *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadChatMembers.t.Errorf("ChatServerRepositoryMock.ReadChatMembers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadChatMembers.ReadChatMembersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadChatMembers.ReadChatMembersMock.defaultExpectation.results
		if mm_results == nil {
			mmReadChatMembers.t.Fatal("No results are set for the ChatServerRepositoryMock.ReadChatMembers")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmReadChatMembers.funcReadChatMembers != nil {
		return mmReadChatMembers.funcReadChatMembers(ctx, i1)
	}
	mmReadChatMembers.t.Fatalf("Unexpected call to ChatServerRepositoryMock.ReadChatMembers. %v %v", ctx, i1)
	return
}

// ReadChatMembersAfterCounter returns a count of finished ChatServerRepositoryMock.ReadChatMembers invocations
func (mmReadChatMembers *ChatServerRepositoryMock) ReadChatMembersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadChatMembers.afterReadChatMembersCounter)
}

// ReadChatMembersBeforeCounter returns a count of ChatServerRepositoryMock.ReadChatMembers invocations
func (mmReadChatMembers *ChatServerRepositoryMock) ReadChatMembersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadChatMembers.beforeReadChatMembersCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.ReadChatMembers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadChatMembers *mChatServerRepositoryMockReadChatMembers) Calls() []*ChatServerRepositoryMockReadChatMembersParams {
	mmReadChatMembers.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockReadChatMembersParams, len(mmReadChatMembers.callArgs))
	copy(argCopy, mmReadChatMembers.callArgs)

	mmReadChatMembers.mutex.RUnlock()

	return argCopy
}

// MinimockReadChatMembersDone returns true if the count of the ReadChatMembers invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockReadChatMembersDone() bool {
	if m.ReadChatMembersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadChatMembersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadChatMembersMock.invocationsDone()
}

// MinimockReadChatMembersInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockReadChatMembersInspect() {
	for _, e := range m.ReadChatMembersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChatMembers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadChatMembersCounter := mm_atomic.LoadUint64(&m.afterReadChatMembersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadChatMembersMock.defaultExpectation != nil && afterReadChatMembersCounter < 1 {
		if m.ReadChatMembersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChatMembers at\n%s", m.ReadChatMembersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChatMembers at\n%s with params: %#v", m.ReadChatMembersMock.defaultExpectation.expectationOrigins.origin, *m.ReadChatMembersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadChatMembers != nil && afterReadChatMembersCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChatMembers at\n%s", m.funcReadChatMembersOrigin)
	}

	if !m.ReadChatMembersMock.invocationsDone() && afterReadChatMembersCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.ReadChatMembers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadChatMembersMock.expectedInvocations), m.ReadChatMembersMock.expectedInvocationsOrigin, afterReadChatMembersCounter)
	}
}

type mChatServerRepositoryMockReadChats struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockReadChatsExpectation
	expectations       []*ChatServerRepositoryMockReadChatsExpectation

	callArgs []*ChatServerRepositoryMockReadChatsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockReadChatsExpectation specifies expectation struct of the ChatServerRepository.ReadChats
type ChatServerRepositoryMockReadChatsExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockReadChatsParams
	paramPtrs          *ChatServerRepositoryMockReadChatsParamPtrs
	expectationOrigins ChatServerRepositoryMockReadChatsExpectationOrigins
	results            *ChatServerRepositoryMockReadChatsResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockReadChatsParams contains parameters of the ChatServerRepository.ReadChats
type ChatServerRepositoryMockReadChatsParams struct {
	ctx context.Context
}

// ChatServerRepositoryMockReadChatsParamPtrs contains pointers to parameters of the ChatServerRepository.ReadChats
type ChatServerRepositoryMockReadChatsParamPtrs struct {
	ctx *context.Context
}

// ChatServerRepositoryMockReadChatsResults contains results of the ChatServerRepository.ReadChats
type ChatServerRepositoryMockReadChatsResults struct {
	cpa1 []*model.Chat
	err  error
}

// ChatServerRepositoryMockReadChatsOrigins contains origins of expectations of the ChatServerRepository.ReadChats
type ChatServerRepositoryMockReadChatsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadChats *mChatServerRepositoryMockReadChats) Optional() *mChatServerRepositoryMockReadChats {
	mmReadChats.optional = true
	return mmReadChats
}

// Expect sets up expected params for ChatServerRepository.ReadChats
func (mmReadChats *mChatServerRepositoryMockReadChats) Expect(ctx context.Context) *mChatServerRepositoryMockReadChats {
	if mmReadChats.mock.funcReadChats != nil {
		mmReadChats.mock.t.Fatalf("ChatServerRepositoryMock.ReadChats mock is already set by Set")
	}

	if mmReadChats.defaultExpectation == nil {
		mmReadChats.defaultExpectation = &ChatServerRepositoryMockReadChatsExpectation{}
	}

	if mmReadChats.defaultExpectation.paramPtrs != nil {
		mmReadChats.mock.t.Fatalf("ChatServerRepositoryMock.ReadChats mock is already set by ExpectParams functions")
	}

	mmReadChats.defaultExpectation.params = &ChatServerRepositoryMockReadChatsParams{ctx}
	mmReadChats.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadChats.expectations {
		if minimock.Equal(e.params, mmReadChats.defaultExpectation.params) {
			mmReadChats.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadChats.defaultExpectation.params)
		}
	}

	return mmReadChats
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.ReadChats
func (mmReadChats *mChatServerRepositoryMockReadChats) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockReadChats {
	if mmReadChats.mock.funcReadChats != nil {
		mmReadChats.mock.t.Fatalf("ChatServerRepositoryMock.ReadChats mock is already set by Set")
	}

	if mmReadChats.defaultExpectation == nil {
		mmReadChats.defaultExpectation = &ChatServerRepositoryMockReadChatsExpectation{}
	}

	if mmReadChats.defaultExpectation.params != nil {
		mmReadChats.mock.t.Fatalf("ChatServerRepositoryMock.ReadChats mock is already set by Expect")
	}

	if mmReadChats.defaultExpectation.paramPtrs == nil {
		mmReadChats.defaultExpectation.paramPtrs = &ChatServerRepositoryMockReadChatsParamPtrs{}
	}
	mmReadChats.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadChats.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadChats
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.ReadChats
func (mmReadChats *mChatServerRepositoryMockReadChats) Inspect(f func(ctx context.Context)) *mChatServerRepositoryMockReadChats {
	if mmReadChats.mock.inspectFuncReadChats != nil {
		mmReadChats.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.ReadChats")
	}

	mmReadChats.mock.inspectFuncReadChats = f

	return mmReadChats
}

// Return sets up results that will be returned by ChatServerRepository.ReadChats
func (mmReadChats *mChatServerRepositoryMockReadChats) Return(cpa1 []*model.Chat, err error) *ChatServerRepositoryMock {
	if mmReadChats.mock.funcReadChats != nil {
		mmReadChats.mock.t.Fatalf("ChatServerRepositoryMock.ReadChats mock is already set by Set")
	}

	if mmReadChats.defaultExpectation == nil {
		mmReadChats.defaultExpectation = &ChatServerRepositoryMockReadChatsExpectation{mock: mmReadChats.mock}
	}
	mmReadChats.defaultExpectation.results = &ChatServerRepositoryMockReadChatsResults{cpa1, err}
	mmReadChats.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadChats.mock
}

// Set uses given function f to mock the ChatServerRepository.ReadChats method
func (mmReadChats *mChatServerRepositoryMockReadChats) Set(f func(ctx context.Context) (cpa1 []*model.Chat, err error)) *ChatServerRepositoryMock {
	if mmReadChats.defaultExpectation != nil {
		mmReadChats.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.ReadChats method")
	}

	if len(mmReadChats.expectations) > 0 {
		mmReadChats.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.ReadChats method")
	}

	mmReadChats.mock.funcReadChats = f
	mmReadChats.mock.funcReadChatsOrigin = minimock.CallerInfo(1)
	return mmReadChats.mock
}

// When sets expectation for the ChatServerRepository.ReadChats which will trigger the result defined by the following
// Then helper
func (mmReadChats *mChatServerRepositoryMockReadChats) When(ctx context.Context) *ChatServerRepositoryMockReadChatsExpectation {
	if mmReadChats.mock.funcReadChats != nil {
		mmReadChats.mock.t.Fatalf("ChatServerRepositoryMock.ReadChats mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockReadChatsExpectation{
		mock:               mmReadChats.mock,
		params:             &ChatServerRepositoryMockReadChatsParams{ctx},
		expectationOrigins: ChatServerRepositoryMockReadChatsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadChats.expectations = append(mmReadChats.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.ReadChats return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockReadChatsExpectation) Then(cpa1 []*model.Chat, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockReadChatsResults{cpa1, err}
	return e.mock
}

// Times sets number of times ChatServerRepository.ReadChats should be invoked
func (mmReadChats *mChatServerRepositoryMockReadChats) Times(n uint64) *mChatServerRepositoryMockReadChats {
	if n == 0 {
		mmReadChats.mock.t.Fatalf("Times of ChatServerRepositoryMock.ReadChats mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadChats.expectedInvocations, n)
	mmReadChats.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadChats
}

func (mmReadChats *mChatServerRepositoryMockReadChats) invocationsDone() bool {
	if len(mmReadChats.expectations) == 0 && mmReadChats.defaultExpectation == nil && mmReadChats.mock.funcReadChats == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadChats.mock.afterReadChatsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadChats.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReadChats implements mm_repository.ChatServerRepository
func (mmReadChats *ChatServerRepositoryMock) ReadChats(ctx context.Context) (cpa1 []*model.Chat, err error) {
	mm_atomic.AddUint64(&mmReadChats.beforeReadChatsCounter, 1)
	defer mm_atomic.AddUint64(&mmReadChats.afterReadChatsCounter, 1)

	mmReadChats.t.Helper()

	if mmReadChats.inspectFuncReadChats != nil {
		mmReadChats.inspectFuncReadChats(ctx)
	}

	mm_params := ChatServerRepositoryMockReadChatsParams{ctx}

	// Record call args
	mmReadChats.ReadChatsMock.mutex.Lock()
	mmReadChats.ReadChatsMock.callArgs = append(mmReadChats.ReadChatsMock.callArgs, &mm_params)
	mmReadChats.ReadChatsMock.mutex.Unlock()

	for _, e := range mmReadChats.ReadChatsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmReadChats.ReadChatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadChats.ReadChatsMock.defaultExpectation.Counter, 1)
		mm_want := mmReadChats.ReadChatsMock.defaultExpectation.params
		mm_want_ptrs := mmReadChats.ReadChatsMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockReadChatsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadChats.t.Errorf("ChatServerRepositoryMock.ReadChats got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadChats.ReadChatsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadChats.t.Errorf("ChatServerRepositoryMock.ReadChats got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadChats.ReadChatsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadChats.ReadChatsMock.defaultExpectation.results
		if mm_results == nil {
			mmReadChats.t.Fatal("No results are set for the ChatServerRepositoryMock.ReadChats")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmReadChats.funcReadChats != nil {
		return mmReadChats.funcReadChats(ctx)
	}
	mmReadChats.t.Fatalf("Unexpected call to ChatServerRepositoryMock.ReadChats. %v", ctx)
	return
}

// ReadChatsAfterCounter returns a count of finished ChatServerRepositoryMock.ReadChats invocations
func (mmReadChats *ChatServerRepositoryMock) ReadChatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadChats.afterReadChatsCounter)
}

// ReadChatsBeforeCounter returns a count of ChatServerRepositoryMock.ReadChats invocations
func (mmReadChats *ChatServerRepositoryMock) ReadChatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadChats.beforeReadChatsCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.ReadChats.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadChats *mChatServerRepositoryMockReadChats) Calls() []*ChatServerRepositoryMockReadChatsParams {
	mmReadChats.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockReadChatsParams, len(mmReadChats.callArgs))
	copy(argCopy, mmReadChats.callArgs)

	mmReadChats.mutex.RUnlock()

	return argCopy
}

// MinimockReadChatsDone returns true if the count of the ReadChats invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockReadChatsDone() bool {
	if m.ReadChatsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadChatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadChatsMock.invocationsDone()
}

// MinimockReadChatsInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockReadChatsInspect() {
	for _, e := range m.ReadChatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChats at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadChatsCounter := mm_atomic.LoadUint64(&m.afterReadChatsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadChatsMock.defaultExpectation != nil && afterReadChatsCounter < 1 {
		if m.ReadChatsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChats at\n%s", m.ReadChatsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChats at\n%s with params: %#v", m.ReadChatsMock.defaultExpectation.expectationOrigins.origin, *m.ReadChatsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadChats != nil && afterReadChatsCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadChats at\n%s", m.funcReadChatsOrigin)
	}

	if !m.ReadChatsMock.invocationsDone() && afterReadChatsCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.ReadChats at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadChatsMock.expectedInvocations), m.ReadChatsMock.expectedInvocationsOrigin, afterReadChatsCounter)
	}
}

type mChatServerRepositoryMockReadMessages struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockReadMessagesExpectation
	expectations       []*ChatServerRepositoryMockReadMessagesExpectation

	callArgs []*ChatServerRepositoryMockReadMessagesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockReadMessagesExpectation specifies expectation struct of the ChatServerRepository.ReadMessages
type ChatServerRepositoryMockReadMessagesExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockReadMessagesParams
	paramPtrs          *ChatServerRepositoryMockReadMessagesParamPtrs
	expectationOrigins ChatServerRepositoryMockReadMessagesExpectationOrigins
	results            *ChatServerRepositoryMockReadMessagesResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockReadMessagesParams contains parameters of the ChatServerRepository.ReadMessages
type ChatServerRepositoryMockReadMessagesParams struct {
	ctx context.Context
	i1  int
}

// ChatServerRepositoryMockReadMessagesParamPtrs contains pointers to parameters of the ChatServerRepository.ReadMessages
type ChatServerRepositoryMockReadMessagesParamPtrs struct {
	ctx *context.Context
	i1  *int
}

// ChatServerRepositoryMockReadMessagesResults contains results of the ChatServerRepository.ReadMessages
type ChatServerRepositoryMockReadMessagesResults struct {
	mpa1 []*model.Message
	err  error
}

// ChatServerRepositoryMockReadMessagesOrigins contains origins of expectations of the ChatServerRepository.ReadMessages
type ChatServerRepositoryMockReadMessagesExpectationOrigins struct {
	origin    string
	originCtx string
	originI1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadMessages *mChatServerRepositoryMockReadMessages) Optional() *mChatServerRepositoryMockReadMessages {
	mmReadMessages.optional = true
	return mmReadMessages
}

// Expect sets up expected params for ChatServerRepository.ReadMessages
func (mmReadMessages *mChatServerRepositoryMockReadMessages) Expect(ctx context.Context, i1 int) *mChatServerRepositoryMockReadMessages {
	if mmReadMessages.mock.funcReadMessages != nil {
		mmReadMessages.mock.t.Fatalf("ChatServerRepositoryMock.ReadMessages mock is already set by Set")
	}

	if mmReadMessages.defaultExpectation == nil {
		mmReadMessages.defaultExpectation = &ChatServerRepositoryMockReadMessagesExpectation{}
	}

	if mmReadMessages.defaultExpectation.paramPtrs != nil {
		mmReadMessages.mock.t.Fatalf("ChatServerRepositoryMock.ReadMessages mock is already set by ExpectParams functions")
	}

	mmReadMessages.defaultExpectation.params = &ChatServerRepositoryMockReadMessagesParams{ctx, i1}
	mmReadMessages.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadMessages.expectations {
		if minimock.Equal(e.params, mmReadMessages.defaultExpectation.params) {
			mmReadMessages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadMessages.defaultExpectation.params)
		}
	}

	return mmReadMessages
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.ReadMessages
func (mmReadMessages *mChatServerRepositoryMockReadMessages) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockReadMessages {
	if mmReadMessages.mock.funcReadMessages != nil {
		mmReadMessages.mock.t.Fatalf("ChatServerRepositoryMock.ReadMessages mock is already set by Set")
	}

	if mmReadMessages.defaultExpectation == nil {
		mmReadMessages.defaultExpectation = &ChatServerRepositoryMockReadMessagesExpectation{}
	}

	if mmReadMessages.defaultExpectation.params != nil {
		mmReadMessages.mock.t.Fatalf("ChatServerRepositoryMock.ReadMessages mock is already set by Expect")
	}

	if mmReadMessages.defaultExpectation.paramPtrs == nil {
		mmReadMessages.defaultExpectation.paramPtrs = &ChatServerRepositoryMockReadMessagesParamPtrs{}
	}
	mmReadMessages.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadMessages.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadMessages
}

// ExpectI1Param2 sets up expected param i1 for ChatServerRepository.ReadMessages
func (mmReadMessages *mChatServerRepositoryMockReadMessages) ExpectI1Param2(i1 int) *mChatServerRepositoryMockReadMessages {
	if mmReadMessages.mock.funcReadMessages != nil {
		mmReadMessages.mock.t.Fatalf("ChatServerRepositoryMock.ReadMessages mock is already set by Set")
	}

	if mmReadMessages.defaultExpectation == nil {
		mmReadMessages.defaultExpectation = &ChatServerRepositoryMockReadMessagesExpectation{}
	}

	if mmReadMessages.defaultExpectation.params != nil {
		mmReadMessages.mock.t.Fatalf("ChatServerRepositoryMock.ReadMessages mock is already set by Expect")
	}

	if mmReadMessages.defaultExpectation.paramPtrs == nil {
		mmReadMessages.defaultExpectation.paramPtrs = &ChatServerRepositoryMockReadMessagesParamPtrs{}
	}
	mmReadMessages.defaultExpectation.paramPtrs.i1 = &i1
	mmReadMessages.defaultExpectation.expectationOrigins.originI1 = minimock.CallerInfo(1)

	return mmReadMessages
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.ReadMessages
func (mmReadMessages *mChatServerRepositoryMockReadMessages) Inspect(f func(ctx context.Context, i1 int)) *mChatServerRepositoryMockReadMessages {
	if mmReadMessages.mock.inspectFuncReadMessages != nil {
		mmReadMessages.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.ReadMessages")
	}

	mmReadMessages.mock.inspectFuncReadMessages = f

	return mmReadMessages
}

// Return sets up results that will be returned by ChatServerRepository.ReadMessages
func (mmReadMessages *mChatServerRepositoryMockReadMessages) Return(mpa1 []*model.Message, err error) *ChatServerRepositoryMock {
	if mmReadMessages.mock.funcReadMessages != nil {
		mmReadMessages.mock.t.Fatalf("ChatServerRepositoryMock.ReadMessages mock is already set by Set")
	}

	if mmReadMessages.defaultExpectation == nil {
		mmReadMessages.defaultExpectation = &ChatServerRepositoryMockReadMessagesExpectation{mock: mmReadMessages.mock}
	}
	mmReadMessages.defaultExpectation.results = &ChatServerRepositoryMockReadMessagesResults{mpa1, err}
	mmReadMessages.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadMessages.mock
}

// Set uses given function f to mock the ChatServerRepository.ReadMessages method
func (mmReadMessages *mChatServerRepositoryMockReadMessages) Set(f func(ctx context.Context, i1 int) (mpa1 []*model.Message, err error)) *ChatServerRepositoryMock {
	if mmReadMessages.defaultExpectation != nil {
		mmReadMessages.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.ReadMessages method")
	}

	if len(mmReadMessages.expectations) > 0 {
		mmReadMessages.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.ReadMessages method")
	}

	mmReadMessages.mock.funcReadMessages = f
	mmReadMessages.mock.funcReadMessagesOrigin = minimock.CallerInfo(1)
	return mmReadMessages.mock
}

// When sets expectation for the ChatServerRepository.ReadMessages which will trigger the result defined by the following
// Then helper
func (mmReadMessages *mChatServerRepositoryMockReadMessages) When(ctx context.Context, i1 int) *ChatServerRepositoryMockReadMessagesExpectation {
	if mmReadMessages.mock.funcReadMessages != nil {
		mmReadMessages.mock.t.Fatalf("ChatServerRepositoryMock.ReadMessages mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockReadMessagesExpectation{
		mock:               mmReadMessages.mock,
		params:             &ChatServerRepositoryMockReadMessagesParams{ctx, i1},
		expectationOrigins: ChatServerRepositoryMockReadMessagesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadMessages.expectations = append(mmReadMessages.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.ReadMessages return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockReadMessagesExpectation) Then(mpa1 []*model.Message, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockReadMessagesResults{mpa1, err}
	return e.mock
}

// Times sets number of times ChatServerRepository.ReadMessages should be invoked
func (mmReadMessages *mChatServerRepositoryMockReadMessages) Times(n uint64) *mChatServerRepositoryMockReadMessages {
	if n == 0 {
		mmReadMessages.mock.t.Fatalf("Times of ChatServerRepositoryMock.ReadMessages mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadMessages.expectedInvocations, n)
	mmReadMessages.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadMessages
}

func (mmReadMessages *mChatServerRepositoryMockReadMessages) invocationsDone() bool {
	if len(mmReadMessages.expectations) == 0 && mmReadMessages.defaultExpectation == nil && mmReadMessages.mock.funcReadMessages == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadMessages.mock.afterReadMessagesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadMessages.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReadMessages implements mm_repository.ChatServerRepository
func (mmReadMessages *ChatServerRepositoryMock) ReadMessages(ctx context.Context, i1 int) (mpa1 []*model.Message, err error) {
	mm_atomic.AddUint64(&mmReadMessages.beforeReadMessagesCounter, 1)
	defer mm_atomic.AddUint64(&mmReadMessages.afterReadMessagesCounter, 1)

	mmReadMessages.t.Helper()

	if mmReadMessages.inspectFuncReadMessages != nil {
		mmReadMessages.inspectFuncReadMessages(ctx, i1)
	}

	mm_params := ChatServerRepositoryMockReadMessagesParams{ctx, i1}

	// Record call args
	mmReadMessages.ReadMessagesMock.mutex.Lock()
	mmReadMessages.ReadMessagesMock.callArgs = append(mmReadMessages.ReadMessagesMock.callArgs, &mm_params)
	mmReadMessages.ReadMessagesMock.mutex.Unlock()

	for _, e := range mmReadMessages.ReadMessagesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1, e.results.err
		}
	}

	if mmReadMessages.ReadMessagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadMessages.ReadMessagesMock.defaultExpectation.Counter, 1)
		mm_want := mmReadMessages.ReadMessagesMock.defaultExpectation.params
		mm_want_ptrs := mmReadMessages.ReadMessagesMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockReadMessagesParams{ctx, i1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadMessages.t.Errorf("ChatServerRepositoryMock.ReadMessages got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadMessages.ReadMessagesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmReadMessages.t.Errorf("ChatServerRepositoryMock.ReadMessages got unexpected parameter i1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadMessages.ReadMessagesMock.defaultExpectation.expectationOrigins.originI1, *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadMessages.t.Errorf("ChatServerRepositoryMock.ReadMessages got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadMessages.ReadMessagesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadMessages.ReadMessagesMock.defaultExpectation.results
		if mm_results == nil {
			mmReadMessages.t.Fatal("No results are set for the ChatServerRepositoryMock.ReadMessages")
		}
		return (*mm_results).mpa1, (*mm_results).err
	}
	if mmReadMessages.funcReadMessages != nil {
		return mmReadMessages.funcReadMessages(ctx, i1)
	}
	mmReadMessages.t.Fatalf("Unexpected call to ChatServerRepositoryMock.ReadMessages. %v %v", ctx, i1)
	return
}

// ReadMessagesAfterCounter returns a count of finished ChatServerRepositoryMock.ReadMessages invocations
func (mmReadMessages *ChatServerRepositoryMock) ReadMessagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadMessages.afterReadMessagesCounter)
}

// ReadMessagesBeforeCounter returns a count of ChatServerRepositoryMock.ReadMessages invocations
func (mmReadMessages *ChatServerRepositoryMock) ReadMessagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadMessages.beforeReadMessagesCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.ReadMessages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadMessages *mChatServerRepositoryMockReadMessages) Calls() []*ChatServerRepositoryMockReadMessagesParams {
	mmReadMessages.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockReadMessagesParams, len(mmReadMessages.callArgs))
	copy(argCopy, mmReadMessages.callArgs)

	mmReadMessages.mutex.RUnlock()

	return argCopy
}

// MinimockReadMessagesDone returns true if the count of the ReadMessages invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockReadMessagesDone() bool {
	if m.ReadMessagesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadMessagesMock.invocationsDone()
}

// MinimockReadMessagesInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockReadMessagesInspect() {
	for _, e := range m.ReadMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadMessages at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadMessagesCounter := mm_atomic.LoadUint64(&m.afterReadMessagesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMessagesMock.defaultExpectation != nil && afterReadMessagesCounter < 1 {
		if m.ReadMessagesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadMessages at\n%s", m.ReadMessagesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadMessages at\n%s with params: %#v", m.ReadMessagesMock.defaultExpectation.expectationOrigins.origin, *m.ReadMessagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadMessages != nil && afterReadMessagesCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.ReadMessages at\n%s", m.funcReadMessagesOrigin)
	}

	if !m.ReadMessagesMock.invocationsDone() && afterReadMessagesCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.ReadMessages at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadMessagesMock.expectedInvocations), m.ReadMessagesMock.expectedInvocationsOrigin, afterReadMessagesCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServerRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateChatInspect()

			m.MinimockCreateChatMemberInspect()

			m.MinimockCreateLogInspect()

			m.MinimockCreateMessageInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockDeleteChatMemberInspect()

			m.MinimockDeleteMessageInspect()

			m.MinimockReadChatInspect()

			m.MinimockReadChatMemberInspect()

			m.MinimockReadChatMembersInspect()

			m.MinimockReadChatsInspect()

			m.MinimockReadMessagesInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServerRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServerRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateChatDone() &&
		m.MinimockCreateChatMemberDone() &&
		m.MinimockCreateLogDone() &&
		m.MinimockCreateMessageDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockDeleteChatMemberDone() &&
		m.MinimockDeleteMessageDone() &&
		m.MinimockReadChatDone() &&
		m.MinimockReadChatMemberDone() &&
		m.MinimockReadChatMembersDone() &&
		m.MinimockReadChatsDone() &&
		m.MinimockReadMessagesDone()
}
